{"/home/travis/build/npmtest/node-npmtest-nativefier/test.js":"/* istanbul instrument in package npmtest_nativefier */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-nativefier/lib.npmtest_nativefier.js":"/* istanbul instrument in package npmtest_nativefier */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_nativefier = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_nativefier = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-nativefier/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-nativefier && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_nativefier */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_nativefier\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_nativefier.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_nativefier.rollup.js'] =\n            local.assetsDict['/assets.npmtest_nativefier.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_nativefier.__dirname + '/lib.npmtest_nativefier.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-nativefier/node_modules/nativefier/lib/index.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nrequire('source-map-support/register');\n\nrequire('babel-polyfill');\n\nvar _buildMain = require('./build/buildMain');\n\nvar _buildMain2 = _interopRequireDefault(_buildMain);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = _buildMain2.default;\n//# sourceMappingURL=index.js.map\n","/home/travis/build/npmtest/node-npmtest-nativefier/node_modules/nativefier/lib/build/buildMain.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _path = require('path');\n\nvar _path2 = _interopRequireDefault(_path);\n\nvar _electronPackager = require('electron-packager');\n\nvar _electronPackager2 = _interopRequireDefault(_electronPackager);\n\nvar _tmp = require('tmp');\n\nvar _tmp2 = _interopRequireDefault(_tmp);\n\nvar _ncp = require('ncp');\n\nvar _ncp2 = _interopRequireDefault(_ncp);\n\nvar _async = require('async');\n\nvar _async2 = _interopRequireDefault(_async);\n\nvar _hasbin = require('hasbin');\n\nvar _hasbin2 = _interopRequireDefault(_hasbin);\n\nvar _loglevel = require('loglevel');\n\nvar _loglevel2 = _interopRequireDefault(_loglevel);\n\nvar _dishonestProgress = require('./../helpers/dishonestProgress');\n\nvar _dishonestProgress2 = _interopRequireDefault(_dishonestProgress);\n\nvar _optionsMain = require('./../options/optionsMain');\n\nvar _optionsMain2 = _interopRequireDefault(_optionsMain);\n\nvar _iconBuild = require('./iconBuild');\n\nvar _iconBuild2 = _interopRequireDefault(_iconBuild);\n\nvar _helpers = require('./../helpers/helpers');\n\nvar _helpers2 = _interopRequireDefault(_helpers);\n\nvar _packagerConsole = require('./../helpers/packagerConsole');\n\nvar _packagerConsole2 = _interopRequireDefault(_packagerConsole);\n\nvar _buildApp = require('./buildApp');\n\nvar _buildApp2 = _interopRequireDefault(_buildApp);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar copy = _ncp2.default.ncp;\nvar isWindows = _helpers2.default.isWindows;\n\n/**\n * @callback buildAppCallback\n * @param error\n * @param {string} appPath\n */\n\n/**\n *\n * @param {{}} options\n * @param {buildAppCallback} callback\n */\nfunction buildMain(options, callback) {\n    // pre process app\n\n    var tmpObj = _tmp2.default.dirSync({ unsafeCleanup: true });\n    var tmpPath = tmpObj.name;\n\n    // todo check if this is still needed on later version of packager\n    var packagerConsole = new _packagerConsole2.default();\n\n    var progress = new _dishonestProgress2.default(5);\n\n    _async2.default.waterfall([function (callback) {\n        progress.tick('inferring');\n        (0, _optionsMain2.default)(options, callback);\n    }, function (options, callback) {\n        progress.tick('copying');\n        (0, _buildApp2.default)(options.dir, tmpPath, options, function (error) {\n            if (error) {\n                callback(error);\n                return;\n            }\n            // dir now correctly references the app folder to package\n            options.dir = tmpPath;\n            callback(null, options);\n        });\n    }, function (options, callback) {\n        progress.tick('icons');\n        (0, _iconBuild2.default)(options, function (error, optionsWithIcon) {\n            callback(null, optionsWithIcon);\n        });\n    }, function (options, callback) {\n        progress.tick('packaging');\n        // maybe skip passing icon parameter to electron packager\n        var packageOptions = maybeNoIconOption(options);\n\n        packagerConsole.override();\n\n        (0, _electronPackager2.default)(packageOptions, function (error, appPathArray) {\n\n            // restore console.error\n            packagerConsole.restore();\n\n            // pass options which still contains the icon to waterfall\n            callback(error, options, appPathArray);\n        });\n    }, function (options, appPathArray, callback) {\n        progress.tick('finalizing');\n        // somehow appPathArray is a 1 element array\n        var appPath = getAppPath(appPathArray);\n        if (!appPath) {\n            callback();\n            return;\n        }\n\n        maybeCopyIcons(options, appPath, function (error) {\n            callback(error, appPath);\n        });\n    }], function (error, appPath) {\n        packagerConsole.playback();\n        callback(error, appPath);\n    });\n}\n\n/**\n * Checks the app path array to determine if the packaging was completed successfully\n * @param appPathArray Result from electron-packager\n * @returns {*}\n */\nfunction getAppPath(appPathArray) {\n    if (appPathArray.length === 0) {\n        // directory already exists, --overwrite is not set\n        // exit here\n        return null;\n    }\n\n    if (appPathArray.length > 1) {\n        _loglevel2.default.warn('Warning: This should not be happening, packaged app path contains more than one element:', appPathArray);\n    }\n\n    return appPathArray[0];\n}\n\n/**\n * Removes the `icon` parameter from options if building for Windows while not on Windows and Wine is not installed\n * @param options\n */\nfunction maybeNoIconOption(options) {\n    var packageOptions = JSON.parse(JSON.stringify(options));\n    if (options.platform === 'win32' && !isWindows()) {\n        if (!_hasbin2.default.sync('wine')) {\n            _loglevel2.default.warn('Wine is required to set the icon for a Windows app when packaging on non-windows platforms');\n            packageOptions.icon = null;\n        }\n    }\n    return packageOptions;\n}\n\n/**\n * For windows and linux, we have to copy over the icon to the resources/app folder, which the\n * BrowserWindow is hard coded to read the icon from\n * @param {{}} options\n * @param {string} appPath\n * @param callback\n */\nfunction maybeCopyIcons(options, appPath, callback) {\n    if (!options.icon) {\n        callback();\n        return;\n    }\n\n    if (options.platform === 'darwin') {\n        callback();\n        return;\n    }\n\n    // windows & linux\n    // put the icon file into the app\n    var destIconPath = _path2.default.join(appPath, 'resources/app');\n    var destFileName = 'icon' + _path2.default.extname(options.icon);\n    copy(options.icon, _path2.default.join(destIconPath, destFileName), function (error) {\n        callback(error);\n    });\n}\n\nexports.default = buildMain;\n//# sourceMappingURL=buildMain.js.map\n","/home/travis/build/npmtest/node-npmtest-nativefier/node_modules/nativefier/lib/cli.js":"#! /usr/bin/env node\n'use strict';\n\nrequire('source-map-support/register');\n\nvar _path = require('path');\n\nvar _path2 = _interopRequireDefault(_path);\n\nvar _commander = require('commander');\n\nvar _commander2 = _interopRequireDefault(_commander);\n\nvar _index = require('./index');\n\nvar _index2 = _interopRequireDefault(_index);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar packageJson = require(_path2.default.join('..', 'package'));\n\nfunction collect(val, memo) {\n    memo.push(val);\n    return memo;\n}\n\nif (require.main === module) {\n\n    _commander2.default.version(packageJson.version).arguments('<targetUrl> [dest]').action(function (targetUrl, appDir) {\n        _commander2.default.targetUrl = targetUrl;\n        _commander2.default.out = appDir;\n    }).option('-n, --name <value>', 'app name').option('-p, --platform <value>', '\\'osx\\', \\'linux\\' or \\'windows\\'').option('-a, --arch <value>', '\\'ia32\\' or \\'x64\\'').option('-e, --electron-version <value>', 'electron version to package, without the \\'v\\', see https://github.com/atom/electron/releases').option('--no-overwrite', 'do not override output directory if it already exists, defaults to false').option('-c, --conceal', 'packages the source code within your app into an archive, defaults to false, see http://electron.atom.io/docs/v0.36.0/tutorial/application-packaging/').option('--counter', 'if the target app should use a persistant counter badge in the dock (OSX only), defaults to false').option('-i, --icon <value>', 'the icon file to use as the icon for the app (should be a .icns file on OSX, .png for Windows and Linux)').option('--width <value>', 'set window default width, defaults to 1280px', parseInt).option('--height <value>', 'set window default height, defaults to 800px', parseInt).option('--min-width <value>', 'set window minimum width, defaults to 0px', parseInt).option('--min-height <value>', 'set window minimum height, defaults to 0px', parseInt).option('--max-width <value>', 'set window maximum width, default is no limit', parseInt).option('--max-height <value>', 'set window maximum height, default is no limit', parseInt).option('-m, --show-menu-bar', 'set menu bar visible, defaults to false').option('-f, --fast-quit', 'quit app after window close (OSX only), defaults to false').option('-u, --user-agent <value>', 'set the user agent string for the app').option('--honest', 'prevent the nativefied app from changing the user agent string to masquerade as a regular chrome browser').option('--ignore-certificate', 'ignore certificate related errors').option('--insecure', 'enable loading of insecure content, defaults to false').option('--flash', 'if flash should be enabled').option('--flash-path <value>', 'path to Chrome flash plugin, find it in `Chrome://plugins`').option('--inject <value>', 'path to a CSS/JS file to be injected', collect, []).option('--full-screen', 'if the app should always be started in full screen').option('--maximize', 'if the app should always be started maximized').option('--hide-window-frame', 'disable window frame and controls').option('--verbose', 'if verbose logs should be displayed').option('--disable-context-menu', 'disable the context menu').option('--disable-dev-tools', 'disable developer tools').option('--zoom <value>', 'default zoom factor to use when the app is opened, defaults to 1.0', parseFloat).option('--internal-urls <value>', 'regular expression of URLs to consider \"internal\"; all other URLs will be opened in an external browser.  (default: URLs on same second-level domain as app)').option('--crash-reporter <value>', 'remote server URL to send crash reports').option('--single-instance', 'allow only a single instance of the application').parse(process.argv);\n\n    if (!process.argv.slice(2).length) {\n        _commander2.default.help();\n    }\n\n    (0, _index2.default)(_commander2.default, function (error, appPath) {\n        if (error) {\n            console.error(error);\n            return;\n        }\n\n        if (!appPath) {\n            // app exists and --overwrite is not passed\n            return;\n        }\n        console.log('App built to ' + appPath);\n    });\n}\n//# sourceMappingURL=cli.js.map\n","/home/travis/build/npmtest/node-npmtest-nativefier/node_modules/nativefier/app/lib/main.js":"/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t__webpack_require__(1);\n\t\n\tvar _fs = __webpack_require__(15);\n\t\n\tvar _fs2 = _interopRequireDefault(_fs);\n\t\n\tvar _path = __webpack_require__(14);\n\t\n\tvar _path2 = _interopRequireDefault(_path);\n\t\n\tvar _electron = __webpack_require__(17);\n\t\n\tvar _loginWindow = __webpack_require__(18);\n\t\n\tvar _loginWindow2 = _interopRequireDefault(_loginWindow);\n\t\n\tvar _mainWindow = __webpack_require__(19);\n\t\n\tvar _mainWindow2 = _interopRequireDefault(_mainWindow);\n\t\n\tvar _helpers = __webpack_require__(34);\n\t\n\tvar _helpers2 = _interopRequireDefault(_helpers);\n\t\n\tvar _inferFlash = __webpack_require__(39);\n\t\n\tvar _inferFlash2 = _interopRequireDefault(_inferFlash);\n\t\n\tvar _electronDl = __webpack_require__(40);\n\t\n\tvar _electronDl2 = _interopRequireDefault(_electronDl);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar isOSX = _helpers2.default.isOSX;\n\t\n\t\n\t(0, _electronDl2.default)();\n\t\n\tvar APP_ARGS_FILE_PATH = _path2.default.join(__dirname, '..', 'nativefier.json');\n\tvar appArgs = JSON.parse(_fs2.default.readFileSync(APP_ARGS_FILE_PATH, 'utf8'));\n\t\n\tvar mainWindow = void 0;\n\t\n\tif (typeof appArgs.flashPluginDir === 'string') {\n\t    _electron.app.commandLine.appendSwitch('ppapi-flash-path', appArgs.flashPluginDir);\n\t} else if (appArgs.flashPluginDir) {\n\t    var flashPath = (0, _inferFlash2.default)();\n\t    _electron.app.commandLine.appendSwitch('ppapi-flash-path', flashPath);\n\t}\n\t\n\tif (appArgs.ignoreCertificate) {\n\t    _electron.app.commandLine.appendSwitch('ignore-certificate-errors');\n\t}\n\t\n\t// do nothing for setDockBadge if not OSX\n\tvar setDockBadge = function setDockBadge() {};\n\t\n\tif (isOSX()) {\n\t    setDockBadge = _electron.app.dock.setBadge;\n\t}\n\t\n\t_electron.app.on('window-all-closed', function () {\n\t    if (!isOSX() || appArgs.fastQuit) {\n\t        _electron.app.quit();\n\t    }\n\t});\n\t\n\t_electron.app.on('activate', function (event, hasVisibleWindows) {\n\t    if (isOSX()) {\n\t        // this is called when the dock is clicked\n\t        if (!hasVisibleWindows) {\n\t            mainWindow.show();\n\t        }\n\t    }\n\t});\n\t\n\t_electron.app.on('before-quit', function () {\n\t    // not fired when the close button on the window is clicked\n\t    if (isOSX()) {\n\t        // need to force a quit as a workaround here to simulate the osx app hiding behaviour\n\t        // Somehow sokution at https://github.com/atom/electron/issues/444#issuecomment-76492576 does not work,\n\t        // e.prevent default appears to persist\n\t\n\t        // might cause issues in the future as before-quit and will-quit events are not called\n\t        _electron.app.exit(0);\n\t    }\n\t});\n\t\n\tif (appArgs.crashReporter) {\n\t    _electron.app.on('will-finish-launching', function () {\n\t        _electron.crashReporter.start({\n\t            productName: appArgs.name,\n\t            submitURL: appArgs.crashReporter,\n\t            autoSubmit: true\n\t        });\n\t    });\n\t}\n\t\n\t_electron.app.on('ready', function () {\n\t    mainWindow = (0, _mainWindow2.default)(appArgs, _electron.app.quit, setDockBadge);\n\t});\n\t\n\t_electron.app.on('login', function (event, webContents, request, authInfo, callback) {\n\t    // for http authentication\n\t    event.preventDefault();\n\t    (0, _loginWindow2.default)(callback);\n\t});\n\t\n\tif (appArgs.singleInstance) {\n\t    var shouldQuit = _electron.app.makeSingleInstance(function () {\n\t        // Someone tried to run a second instance, we should focus our window.\n\t        if (mainWindow) {\n\t            if (mainWindow.isMinimized()) {\n\t                mainWindow.restore();\n\t            }\n\t            mainWindow.focus();\n\t        }\n\t    });\n\t\n\t    if (shouldQuit) {\n\t        _electron.app.quit();\n\t    }\n\t}\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(2).install();\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar SourceMapConsumer = __webpack_require__(3).SourceMapConsumer;\n\tvar path = __webpack_require__(14);\n\t\n\tvar fs;\n\ttry {\n\t  fs = __webpack_require__(15);\n\t  if (!fs.existsSync || !fs.readFileSync) {\n\t    // fs doesn't have all methods we need\n\t    fs = null;\n\t  }\n\t} catch (err) {\n\t  /* nop */\n\t}\n\t\n\t// Only install once if called multiple times\n\tvar errorFormatterInstalled = false;\n\tvar uncaughtShimInstalled = false;\n\t\n\t// If true, the caches are reset before a stack trace formatting operation\n\tvar emptyCacheBetweenOperations = false;\n\t\n\t// Supports {browser, node, auto}\n\tvar environment = \"auto\";\n\t\n\t// Maps a file path to a string containing the file contents\n\tvar fileContentsCache = {};\n\t\n\t// Maps a file path to a source map for that file\n\tvar sourceMapCache = {};\n\t\n\t// Regex for detecting source maps\n\tvar reSourceMap = /^data:application\\/json[^,]+base64,/;\n\t\n\t// Priority list of retrieve handlers\n\tvar retrieveFileHandlers = [];\n\tvar retrieveMapHandlers = [];\n\t\n\tfunction isInBrowser() {\n\t  if (environment === \"browser\")\n\t    return true;\n\t  if (environment === \"node\")\n\t    return false;\n\t  return ((typeof window !== 'undefined') && (typeof XMLHttpRequest === 'function') && !(window.require && window.module && window.process && window.process.type === \"renderer\"));\n\t}\n\t\n\tfunction hasGlobalProcessEventEmitter() {\n\t  return ((typeof process === 'object') && (process !== null) && (typeof process.on === 'function'));\n\t}\n\t\n\tfunction handlerExec(list) {\n\t  return function(arg) {\n\t    for (var i = 0; i < list.length; i++) {\n\t      var ret = list[i](arg);\n\t      if (ret) {\n\t        return ret;\n\t      }\n\t    }\n\t    return null;\n\t  };\n\t}\n\t\n\tvar retrieveFile = handlerExec(retrieveFileHandlers);\n\t\n\tretrieveFileHandlers.push(function(path) {\n\t  // Trim the path to make sure there is no extra whitespace.\n\t  path = path.trim();\n\t  if (path in fileContentsCache) {\n\t    return fileContentsCache[path];\n\t  }\n\t\n\t  var contents = null;\n\t  if (!fs) {\n\t    // Use SJAX if we are in the browser\n\t    var xhr = new XMLHttpRequest();\n\t    xhr.open('GET', path, false);\n\t    xhr.send(null);\n\t    var contents = null\n\t    if (xhr.readyState === 4 && xhr.status === 200) {\n\t      contents = xhr.responseText\n\t    }\n\t  } else if (fs.existsSync(path)) {\n\t    // Otherwise, use the filesystem\n\t    contents = fs.readFileSync(path, 'utf8');\n\t  }\n\t\n\t  return fileContentsCache[path] = contents;\n\t});\n\t\n\t// Support URLs relative to a directory, but be careful about a protocol prefix\n\t// in case we are in the browser (i.e. directories may start with \"http://\")\n\tfunction supportRelativeURL(file, url) {\n\t  if (!file) return url;\n\t  var dir = path.dirname(file);\n\t  var match = /^\\w+:\\/\\/[^\\/]*/.exec(dir);\n\t  var protocol = match ? match[0] : '';\n\t  return protocol + path.resolve(dir.slice(protocol.length), url);\n\t}\n\t\n\tfunction retrieveSourceMapURL(source) {\n\t  var fileData;\n\t\n\t  if (isInBrowser()) {\n\t     try {\n\t       var xhr = new XMLHttpRequest();\n\t       xhr.open('GET', source, false);\n\t       xhr.send(null);\n\t       fileData = xhr.readyState === 4 ? xhr.responseText : null;\n\t\n\t       // Support providing a sourceMappingURL via the SourceMap header\n\t       var sourceMapHeader = xhr.getResponseHeader(\"SourceMap\") ||\n\t                             xhr.getResponseHeader(\"X-SourceMap\");\n\t       if (sourceMapHeader) {\n\t         return sourceMapHeader;\n\t       }\n\t     } catch (e) {\n\t     }\n\t  }\n\t\n\t  // Get the URL of the source map\n\t  fileData = retrieveFile(source);\n\t  var re = /(?:\\/\\/[@#][ \\t]+sourceMappingURL=([^\\s'\"]+?)[ \\t]*$)|(?:\\/\\*[@#][ \\t]+sourceMappingURL=([^\\*]+?)[ \\t]*(?:\\*\\/)[ \\t]*$)/mg;\n\t  // Keep executing the search to find the *last* sourceMappingURL to avoid\n\t  // picking up sourceMappingURLs from comments, strings, etc.\n\t  var lastMatch, match;\n\t  while (match = re.exec(fileData)) lastMatch = match;\n\t  if (!lastMatch) return null;\n\t  return lastMatch[1];\n\t};\n\t\n\t// Can be overridden by the retrieveSourceMap option to install. Takes a\n\t// generated source filename; returns a {map, optional url} object, or null if\n\t// there is no source map.  The map field may be either a string or the parsed\n\t// JSON object (ie, it must be a valid argument to the SourceMapConsumer\n\t// constructor).\n\tvar retrieveSourceMap = handlerExec(retrieveMapHandlers);\n\tretrieveMapHandlers.push(function(source) {\n\t  var sourceMappingURL = retrieveSourceMapURL(source);\n\t  if (!sourceMappingURL) return null;\n\t\n\t  // Read the contents of the source map\n\t  var sourceMapData;\n\t  if (reSourceMap.test(sourceMappingURL)) {\n\t    // Support source map URL as a data url\n\t    var rawData = sourceMappingURL.slice(sourceMappingURL.indexOf(',') + 1);\n\t    sourceMapData = new Buffer(rawData, \"base64\").toString();\n\t    sourceMappingURL = source;\n\t  } else {\n\t    // Support source map URLs relative to the source URL\n\t    sourceMappingURL = supportRelativeURL(source, sourceMappingURL);\n\t    sourceMapData = retrieveFile(sourceMappingURL);\n\t  }\n\t\n\t  if (!sourceMapData) {\n\t    return null;\n\t  }\n\t\n\t  return {\n\t    url: sourceMappingURL,\n\t    map: sourceMapData\n\t  };\n\t});\n\t\n\tfunction mapSourcePosition(position) {\n\t  var sourceMap = sourceMapCache[position.source];\n\t  if (!sourceMap) {\n\t    // Call the (overrideable) retrieveSourceMap function to get the source map.\n\t    var urlAndMap = retrieveSourceMap(position.source);\n\t    if (urlAndMap) {\n\t      sourceMap = sourceMapCache[position.source] = {\n\t        url: urlAndMap.url,\n\t        map: new SourceMapConsumer(urlAndMap.map)\n\t      };\n\t\n\t      // Load all sources stored inline with the source map into the file cache\n\t      // to pretend like they are already loaded. They may not exist on disk.\n\t      if (sourceMap.map.sourcesContent) {\n\t        sourceMap.map.sources.forEach(function(source, i) {\n\t          var contents = sourceMap.map.sourcesContent[i];\n\t          if (contents) {\n\t            var url = supportRelativeURL(sourceMap.url, source);\n\t            fileContentsCache[url] = contents;\n\t          }\n\t        });\n\t      }\n\t    } else {\n\t      sourceMap = sourceMapCache[position.source] = {\n\t        url: null,\n\t        map: null\n\t      };\n\t    }\n\t  }\n\t\n\t  // Resolve the source URL relative to the URL of the source map\n\t  if (sourceMap && sourceMap.map) {\n\t    var originalPosition = sourceMap.map.originalPositionFor(position);\n\t\n\t    // Only return the original position if a matching line was found. If no\n\t    // matching line is found then we return position instead, which will cause\n\t    // the stack trace to print the path and line for the compiled file. It is\n\t    // better to give a precise location in the compiled file than a vague\n\t    // location in the original file.\n\t    if (originalPosition.source !== null) {\n\t      originalPosition.source = supportRelativeURL(\n\t        sourceMap.url, originalPosition.source);\n\t      return originalPosition;\n\t    }\n\t  }\n\t\n\t  return position;\n\t}\n\t\n\t// Parses code generated by FormatEvalOrigin(), a function inside V8:\n\t// https://code.google.com/p/v8/source/browse/trunk/src/messages.js\n\tfunction mapEvalOrigin(origin) {\n\t  // Most eval() calls are in this format\n\t  var match = /^eval at ([^(]+) \\((.+):(\\d+):(\\d+)\\)$/.exec(origin);\n\t  if (match) {\n\t    var position = mapSourcePosition({\n\t      source: match[2],\n\t      line: +match[3],\n\t      column: match[4] - 1\n\t    });\n\t    return 'eval at ' + match[1] + ' (' + position.source + ':' +\n\t      position.line + ':' + (position.column + 1) + ')';\n\t  }\n\t\n\t  // Parse nested eval() calls using recursion\n\t  match = /^eval at ([^(]+) \\((.+)\\)$/.exec(origin);\n\t  if (match) {\n\t    return 'eval at ' + match[1] + ' (' + mapEvalOrigin(match[2]) + ')';\n\t  }\n\t\n\t  // Make sure we still return useful information if we didn't find anything\n\t  return origin;\n\t}\n\t\n\t// This is copied almost verbatim from the V8 source code at\n\t// https://code.google.com/p/v8/source/browse/trunk/src/messages.js. The\n\t// implementation of wrapCallSite() used to just forward to the actual source\n\t// code of CallSite.prototype.toString but unfortunately a new release of V8\n\t// did something to the prototype chain and broke the shim. The only fix I\n\t// could find was copy/paste.\n\tfunction CallSiteToString() {\n\t  var fileName;\n\t  var fileLocation = \"\";\n\t  if (this.isNative()) {\n\t    fileLocation = \"native\";\n\t  } else {\n\t    fileName = this.getScriptNameOrSourceURL();\n\t    if (!fileName && this.isEval()) {\n\t      fileLocation = this.getEvalOrigin();\n\t      fileLocation += \", \";  // Expecting source position to follow.\n\t    }\n\t\n\t    if (fileName) {\n\t      fileLocation += fileName;\n\t    } else {\n\t      // Source code does not originate from a file and is not native, but we\n\t      // can still get the source position inside the source string, e.g. in\n\t      // an eval string.\n\t      fileLocation += \"<anonymous>\";\n\t    }\n\t    var lineNumber = this.getLineNumber();\n\t    if (lineNumber != null) {\n\t      fileLocation += \":\" + lineNumber;\n\t      var columnNumber = this.getColumnNumber();\n\t      if (columnNumber) {\n\t        fileLocation += \":\" + columnNumber;\n\t      }\n\t    }\n\t  }\n\t\n\t  var line = \"\";\n\t  var functionName = this.getFunctionName();\n\t  var addSuffix = true;\n\t  var isConstructor = this.isConstructor();\n\t  var isMethodCall = !(this.isToplevel() || isConstructor);\n\t  if (isMethodCall) {\n\t    var typeName = this.getTypeName();\n\t    // Fixes shim to be backward compatable with Node v0 to v4\n\t    if (typeName === \"[object Object]\") {\n\t      typeName = \"null\";\n\t    }\n\t    var methodName = this.getMethodName();\n\t    if (functionName) {\n\t      if (typeName && functionName.indexOf(typeName) != 0) {\n\t        line += typeName + \".\";\n\t      }\n\t      line += functionName;\n\t      if (methodName && functionName.indexOf(\".\" + methodName) != functionName.length - methodName.length - 1) {\n\t        line += \" [as \" + methodName + \"]\";\n\t      }\n\t    } else {\n\t      line += typeName + \".\" + (methodName || \"<anonymous>\");\n\t    }\n\t  } else if (isConstructor) {\n\t    line += \"new \" + (functionName || \"<anonymous>\");\n\t  } else if (functionName) {\n\t    line += functionName;\n\t  } else {\n\t    line += fileLocation;\n\t    addSuffix = false;\n\t  }\n\t  if (addSuffix) {\n\t    line += \" (\" + fileLocation + \")\";\n\t  }\n\t  return line;\n\t}\n\t\n\tfunction cloneCallSite(frame) {\n\t  var object = {};\n\t  Object.getOwnPropertyNames(Object.getPrototypeOf(frame)).forEach(function(name) {\n\t    object[name] = /^(?:is|get)/.test(name) ? function() { return frame[name].call(frame); } : frame[name];\n\t  });\n\t  object.toString = CallSiteToString;\n\t  return object;\n\t}\n\t\n\tfunction wrapCallSite(frame) {\n\t  if(frame.isNative()) {\n\t    return frame;\n\t  }\n\t\n\t  // Most call sites will return the source file from getFileName(), but code\n\t  // passed to eval() ending in \"//# sourceURL=...\" will return the source file\n\t  // from getScriptNameOrSourceURL() instead\n\t  var source = frame.getFileName() || frame.getScriptNameOrSourceURL();\n\t  if (source) {\n\t    var line = frame.getLineNumber();\n\t    var column = frame.getColumnNumber() - 1;\n\t\n\t    // Fix position in Node where some (internal) code is prepended.\n\t    // See https://github.com/evanw/node-source-map-support/issues/36\n\t    if (line === 1 && !isInBrowser() && !frame.isEval()) {\n\t      column -= 62;\n\t    }\n\t\n\t    var position = mapSourcePosition({\n\t      source: source,\n\t      line: line,\n\t      column: column\n\t    });\n\t    frame = cloneCallSite(frame);\n\t    frame.getFileName = function() { return position.source; };\n\t    frame.getLineNumber = function() { return position.line; };\n\t    frame.getColumnNumber = function() { return position.column + 1; };\n\t    frame.getScriptNameOrSourceURL = function() { return position.source; };\n\t    return frame;\n\t  }\n\t\n\t  // Code called using eval() needs special handling\n\t  var origin = frame.isEval() && frame.getEvalOrigin();\n\t  if (origin) {\n\t    origin = mapEvalOrigin(origin);\n\t    frame = cloneCallSite(frame);\n\t    frame.getEvalOrigin = function() { return origin; };\n\t    return frame;\n\t  }\n\t\n\t  // If we get here then we were unable to change the source position\n\t  return frame;\n\t}\n\t\n\t// This function is part of the V8 stack trace API, for more info see:\n\t// http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi\n\tfunction prepareStackTrace(error, stack) {\n\t  if (emptyCacheBetweenOperations) {\n\t    fileContentsCache = {};\n\t    sourceMapCache = {};\n\t  }\n\t\n\t  return error + stack.map(function(frame) {\n\t    return '\\n    at ' + wrapCallSite(frame);\n\t  }).join('');\n\t}\n\t\n\t// Generate position and snippet of original source with pointer\n\tfunction getErrorSource(error) {\n\t  var match = /\\n    at [^(]+ \\((.*):(\\d+):(\\d+)\\)/.exec(error.stack);\n\t  if (match) {\n\t    var source = match[1];\n\t    var line = +match[2];\n\t    var column = +match[3];\n\t\n\t    // Support the inline sourceContents inside the source map\n\t    var contents = fileContentsCache[source];\n\t\n\t    // Support files on disk\n\t    if (!contents && fs && fs.existsSync(source)) {\n\t      contents = fs.readFileSync(source, 'utf8');\n\t    }\n\t\n\t    // Format the line from the original source code like node does\n\t    if (contents) {\n\t      var code = contents.split(/(?:\\r\\n|\\r|\\n)/)[line - 1];\n\t      if (code) {\n\t        return source + ':' + line + '\\n' + code + '\\n' +\n\t          new Array(column).join(' ') + '^';\n\t      }\n\t    }\n\t  }\n\t  return null;\n\t}\n\t\n\tfunction printErrorAndExit (error) {\n\t  var source = getErrorSource(error);\n\t\n\t  if (source) {\n\t    console.error();\n\t    console.error(source);\n\t  }\n\t\n\t  console.error(error.stack);\n\t  process.exit(1);\n\t}\n\t\n\tfunction shimEmitUncaughtException () {\n\t  var origEmit = process.emit;\n\t\n\t  process.emit = function (type) {\n\t    if (type === 'uncaughtException') {\n\t      var hasStack = (arguments[1] && arguments[1].stack);\n\t      var hasListeners = (this.listeners(type).length > 0);\n\t\n\t      if (hasStack && !hasListeners) {\n\t        return printErrorAndExit(arguments[1]);\n\t      }\n\t    }\n\t\n\t    return origEmit.apply(this, arguments);\n\t  };\n\t}\n\t\n\texports.wrapCallSite = wrapCallSite;\n\texports.getErrorSource = getErrorSource;\n\texports.mapSourcePosition = mapSourcePosition;\n\texports.retrieveSourceMap = retrieveSourceMap;\n\t\n\texports.install = function(options) {\n\t  options = options || {};\n\t\n\t  if (options.environment) {\n\t    environment = options.environment;\n\t    if ([\"node\", \"browser\", \"auto\"].indexOf(environment) === -1) {\n\t      throw new Error(\"environment \" + environment + \" was unknown. Available options are {auto, browser, node}\")\n\t    }\n\t  }\n\t\n\t  // Allow sources to be found by methods other than reading the files\n\t  // directly from disk.\n\t  if (options.retrieveFile) {\n\t    if (options.overrideRetrieveFile) {\n\t      retrieveFileHandlers.length = 0;\n\t    }\n\t\n\t    retrieveFileHandlers.unshift(options.retrieveFile);\n\t  }\n\t\n\t  // Allow source maps to be found by methods other than reading the files\n\t  // directly from disk.\n\t  if (options.retrieveSourceMap) {\n\t    if (options.overrideRetrieveSourceMap) {\n\t      retrieveMapHandlers.length = 0;\n\t    }\n\t\n\t    retrieveMapHandlers.unshift(options.retrieveSourceMap);\n\t  }\n\t\n\t  // Support runtime transpilers that include inline source maps\n\t  if (options.hookRequire && !isInBrowser()) {\n\t    var Module;\n\t    try {\n\t      Module = __webpack_require__(16);\n\t    } catch (err) {\n\t      // NOP: Loading in catch block to convert webpack error to warning.\n\t    }\n\t    var $compile = Module.prototype._compile;\n\t\n\t    if (!$compile.__sourceMapSupport) {\n\t      Module.prototype._compile = function(content, filename) {\n\t        fileContentsCache[filename] = content;\n\t        sourceMapCache[filename] = undefined;\n\t        return $compile.call(this, content, filename);\n\t      };\n\t\n\t      Module.prototype._compile.__sourceMapSupport = true;\n\t    }\n\t  }\n\t\n\t  // Configure options\n\t  if (!emptyCacheBetweenOperations) {\n\t    emptyCacheBetweenOperations = 'emptyCacheBetweenOperations' in options ?\n\t      options.emptyCacheBetweenOperations : false;\n\t  }\n\t\n\t  // Install the error reformatter\n\t  if (!errorFormatterInstalled) {\n\t    errorFormatterInstalled = true;\n\t    Error.prepareStackTrace = prepareStackTrace;\n\t  }\n\t\n\t  if (!uncaughtShimInstalled) {\n\t    var installHandler = 'handleUncaughtExceptions' in options ?\n\t      options.handleUncaughtExceptions : true;\n\t\n\t    // Provide the option to not install the uncaught exception handler. This is\n\t    // to support other uncaught exception handlers (in test frameworks, for\n\t    // example). If this handler is not installed and there are no other uncaught\n\t    // exception handlers, uncaught exceptions will be caught by node's built-in\n\t    // exception handler and the process will still be terminated. However, the\n\t    // generated JavaScript code will be shown above the stack trace instead of\n\t    // the original source code.\n\t    if (installHandler && hasGlobalProcessEventEmitter()) {\n\t      uncaughtShimInstalled = true;\n\t      shimEmitUncaughtException();\n\t    }\n\t  }\n\t};\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*\n\t * Copyright 2009-2011 Mozilla Foundation and contributors\n\t * Licensed under the New BSD license. See LICENSE.txt or:\n\t * http://opensource.org/licenses/BSD-3-Clause\n\t */\n\texports.SourceMapGenerator = __webpack_require__(4).SourceMapGenerator;\n\texports.SourceMapConsumer = __webpack_require__(10).SourceMapConsumer;\n\texports.SourceNode = __webpack_require__(13).SourceNode;\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* -*- Mode: js; js-indent-level: 2; -*- */\n\t/*\n\t * Copyright 2011 Mozilla Foundation and contributors\n\t * Licensed under the New BSD license. See LICENSE or:\n\t * http://opensource.org/licenses/BSD-3-Clause\n\t */\n\t\n\tvar base64VLQ = __webpack_require__(5);\n\tvar util = __webpack_require__(7);\n\tvar ArraySet = __webpack_require__(8).ArraySet;\n\tvar MappingList = __webpack_require__(9).MappingList;\n\t\n\t/**\n\t * An instance of the SourceMapGenerator represents a source map which is\n\t * being built incrementally. You may pass an object with the following\n\t * properties:\n\t *\n\t *   - file: The filename of the generated source.\n\t *   - sourceRoot: A root for all relative URLs in this source map.\n\t */\n\tfunction SourceMapGenerator(aArgs) {\n\t  if (!aArgs) {\n\t    aArgs = {};\n\t  }\n\t  this._file = util.getArg(aArgs, 'file', null);\n\t  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);\n\t  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);\n\t  this._sources = new ArraySet();\n\t  this._names = new ArraySet();\n\t  this._mappings = new MappingList();\n\t  this._sourcesContents = null;\n\t}\n\t\n\tSourceMapGenerator.prototype._version = 3;\n\t\n\t/**\n\t * Creates a new SourceMapGenerator based on a SourceMapConsumer\n\t *\n\t * @param aSourceMapConsumer The SourceMap.\n\t */\n\tSourceMapGenerator.fromSourceMap =\n\t  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {\n\t    var sourceRoot = aSourceMapConsumer.sourceRoot;\n\t    var generator = new SourceMapGenerator({\n\t      file: aSourceMapConsumer.file,\n\t      sourceRoot: sourceRoot\n\t    });\n\t    aSourceMapConsumer.eachMapping(function (mapping) {\n\t      var newMapping = {\n\t        generated: {\n\t          line: mapping.generatedLine,\n\t          column: mapping.generatedColumn\n\t        }\n\t      };\n\t\n\t      if (mapping.source != null) {\n\t        newMapping.source = mapping.source;\n\t        if (sourceRoot != null) {\n\t          newMapping.source = util.relative(sourceRoot, newMapping.source);\n\t        }\n\t\n\t        newMapping.original = {\n\t          line: mapping.originalLine,\n\t          column: mapping.originalColumn\n\t        };\n\t\n\t        if (mapping.name != null) {\n\t          newMapping.name = mapping.name;\n\t        }\n\t      }\n\t\n\t      generator.addMapping(newMapping);\n\t    });\n\t    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n\t      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n\t      if (content != null) {\n\t        generator.setSourceContent(sourceFile, content);\n\t      }\n\t    });\n\t    return generator;\n\t  };\n\t\n\t/**\n\t * Add a single mapping from original source line and column to the generated\n\t * source's line and column for this source map being created. The mapping\n\t * object should have the following properties:\n\t *\n\t *   - generated: An object with the generated line and column positions.\n\t *   - original: An object with the original line and column positions.\n\t *   - source: The original source file (relative to the sourceRoot).\n\t *   - name: An optional original token name for this mapping.\n\t */\n\tSourceMapGenerator.prototype.addMapping =\n\t  function SourceMapGenerator_addMapping(aArgs) {\n\t    var generated = util.getArg(aArgs, 'generated');\n\t    var original = util.getArg(aArgs, 'original', null);\n\t    var source = util.getArg(aArgs, 'source', null);\n\t    var name = util.getArg(aArgs, 'name', null);\n\t\n\t    if (!this._skipValidation) {\n\t      this._validateMapping(generated, original, source, name);\n\t    }\n\t\n\t    if (source != null) {\n\t      source = String(source);\n\t      if (!this._sources.has(source)) {\n\t        this._sources.add(source);\n\t      }\n\t    }\n\t\n\t    if (name != null) {\n\t      name = String(name);\n\t      if (!this._names.has(name)) {\n\t        this._names.add(name);\n\t      }\n\t    }\n\t\n\t    this._mappings.add({\n\t      generatedLine: generated.line,\n\t      generatedColumn: generated.column,\n\t      originalLine: original != null && original.line,\n\t      originalColumn: original != null && original.column,\n\t      source: source,\n\t      name: name\n\t    });\n\t  };\n\t\n\t/**\n\t * Set the source content for a source file.\n\t */\n\tSourceMapGenerator.prototype.setSourceContent =\n\t  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {\n\t    var source = aSourceFile;\n\t    if (this._sourceRoot != null) {\n\t      source = util.relative(this._sourceRoot, source);\n\t    }\n\t\n\t    if (aSourceContent != null) {\n\t      // Add the source content to the _sourcesContents map.\n\t      // Create a new _sourcesContents map if the property is null.\n\t      if (!this._sourcesContents) {\n\t        this._sourcesContents = Object.create(null);\n\t      }\n\t      this._sourcesContents[util.toSetString(source)] = aSourceContent;\n\t    } else if (this._sourcesContents) {\n\t      // Remove the source file from the _sourcesContents map.\n\t      // If the _sourcesContents map is empty, set the property to null.\n\t      delete this._sourcesContents[util.toSetString(source)];\n\t      if (Object.keys(this._sourcesContents).length === 0) {\n\t        this._sourcesContents = null;\n\t      }\n\t    }\n\t  };\n\t\n\t/**\n\t * Applies the mappings of a sub-source-map for a specific source file to the\n\t * source map being generated. Each mapping to the supplied source file is\n\t * rewritten using the supplied source map. Note: The resolution for the\n\t * resulting mappings is the minimium of this map and the supplied map.\n\t *\n\t * @param aSourceMapConsumer The source map to be applied.\n\t * @param aSourceFile Optional. The filename of the source file.\n\t *        If omitted, SourceMapConsumer's file property will be used.\n\t * @param aSourceMapPath Optional. The dirname of the path to the source map\n\t *        to be applied. If relative, it is relative to the SourceMapConsumer.\n\t *        This parameter is needed when the two source maps aren't in the same\n\t *        directory, and the source map to be applied contains relative source\n\t *        paths. If so, those relative source paths need to be rewritten\n\t *        relative to the SourceMapGenerator.\n\t */\n\tSourceMapGenerator.prototype.applySourceMap =\n\t  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {\n\t    var sourceFile = aSourceFile;\n\t    // If aSourceFile is omitted, we will use the file property of the SourceMap\n\t    if (aSourceFile == null) {\n\t      if (aSourceMapConsumer.file == null) {\n\t        throw new Error(\n\t          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +\n\t          'or the source map\\'s \"file\" property. Both were omitted.'\n\t        );\n\t      }\n\t      sourceFile = aSourceMapConsumer.file;\n\t    }\n\t    var sourceRoot = this._sourceRoot;\n\t    // Make \"sourceFile\" relative if an absolute Url is passed.\n\t    if (sourceRoot != null) {\n\t      sourceFile = util.relative(sourceRoot, sourceFile);\n\t    }\n\t    // Applying the SourceMap can add and remove items from the sources and\n\t    // the names array.\n\t    var newSources = new ArraySet();\n\t    var newNames = new ArraySet();\n\t\n\t    // Find mappings for the \"sourceFile\"\n\t    this._mappings.unsortedForEach(function (mapping) {\n\t      if (mapping.source === sourceFile && mapping.originalLine != null) {\n\t        // Check if it can be mapped by the source map, then update the mapping.\n\t        var original = aSourceMapConsumer.originalPositionFor({\n\t          line: mapping.originalLine,\n\t          column: mapping.originalColumn\n\t        });\n\t        if (original.source != null) {\n\t          // Copy mapping\n\t          mapping.source = original.source;\n\t          if (aSourceMapPath != null) {\n\t            mapping.source = util.join(aSourceMapPath, mapping.source)\n\t          }\n\t          if (sourceRoot != null) {\n\t            mapping.source = util.relative(sourceRoot, mapping.source);\n\t          }\n\t          mapping.originalLine = original.line;\n\t          mapping.originalColumn = original.column;\n\t          if (original.name != null) {\n\t            mapping.name = original.name;\n\t          }\n\t        }\n\t      }\n\t\n\t      var source = mapping.source;\n\t      if (source != null && !newSources.has(source)) {\n\t        newSources.add(source);\n\t      }\n\t\n\t      var name = mapping.name;\n\t      if (name != null && !newNames.has(name)) {\n\t        newNames.add(name);\n\t      }\n\t\n\t    }, this);\n\t    this._sources = newSources;\n\t    this._names = newNames;\n\t\n\t    // Copy sourcesContents of applied map.\n\t    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n\t      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n\t      if (content != null) {\n\t        if (aSourceMapPath != null) {\n\t          sourceFile = util.join(aSourceMapPath, sourceFile);\n\t        }\n\t        if (sourceRoot != null) {\n\t          sourceFile = util.relative(sourceRoot, sourceFile);\n\t        }\n\t        this.setSourceContent(sourceFile, content);\n\t      }\n\t    }, this);\n\t  };\n\t\n\t/**\n\t * A mapping can have one of the three levels of data:\n\t *\n\t *   1. Just the generated position.\n\t *   2. The Generated position, original position, and original source.\n\t *   3. Generated and original position, original source, as well as a name\n\t *      token.\n\t *\n\t * To maintain consistency, we validate that any new mapping being added falls\n\t * in to one of these categories.\n\t */\n\tSourceMapGenerator.prototype._validateMapping =\n\t  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,\n\t                                              aName) {\n\t    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\n\t        && aGenerated.line > 0 && aGenerated.column >= 0\n\t        && !aOriginal && !aSource && !aName) {\n\t      // Case 1.\n\t      return;\n\t    }\n\t    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\n\t             && aOriginal && 'line' in aOriginal && 'column' in aOriginal\n\t             && aGenerated.line > 0 && aGenerated.column >= 0\n\t             && aOriginal.line > 0 && aOriginal.column >= 0\n\t             && aSource) {\n\t      // Cases 2 and 3.\n\t      return;\n\t    }\n\t    else {\n\t      throw new Error('Invalid mapping: ' + JSON.stringify({\n\t        generated: aGenerated,\n\t        source: aSource,\n\t        original: aOriginal,\n\t        name: aName\n\t      }));\n\t    }\n\t  };\n\t\n\t/**\n\t * Serialize the accumulated mappings in to the stream of base 64 VLQs\n\t * specified by the source map format.\n\t */\n\tSourceMapGenerator.prototype._serializeMappings =\n\t  function SourceMapGenerator_serializeMappings() {\n\t    var previousGeneratedColumn = 0;\n\t    var previousGeneratedLine = 1;\n\t    var previousOriginalColumn = 0;\n\t    var previousOriginalLine = 0;\n\t    var previousName = 0;\n\t    var previousSource = 0;\n\t    var result = '';\n\t    var next;\n\t    var mapping;\n\t    var nameIdx;\n\t    var sourceIdx;\n\t\n\t    var mappings = this._mappings.toArray();\n\t    for (var i = 0, len = mappings.length; i < len; i++) {\n\t      mapping = mappings[i];\n\t      next = ''\n\t\n\t      if (mapping.generatedLine !== previousGeneratedLine) {\n\t        previousGeneratedColumn = 0;\n\t        while (mapping.generatedLine !== previousGeneratedLine) {\n\t          next += ';';\n\t          previousGeneratedLine++;\n\t        }\n\t      }\n\t      else {\n\t        if (i > 0) {\n\t          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {\n\t            continue;\n\t          }\n\t          next += ',';\n\t        }\n\t      }\n\t\n\t      next += base64VLQ.encode(mapping.generatedColumn\n\t                                 - previousGeneratedColumn);\n\t      previousGeneratedColumn = mapping.generatedColumn;\n\t\n\t      if (mapping.source != null) {\n\t        sourceIdx = this._sources.indexOf(mapping.source);\n\t        next += base64VLQ.encode(sourceIdx - previousSource);\n\t        previousSource = sourceIdx;\n\t\n\t        // lines are stored 0-based in SourceMap spec version 3\n\t        next += base64VLQ.encode(mapping.originalLine - 1\n\t                                   - previousOriginalLine);\n\t        previousOriginalLine = mapping.originalLine - 1;\n\t\n\t        next += base64VLQ.encode(mapping.originalColumn\n\t                                   - previousOriginalColumn);\n\t        previousOriginalColumn = mapping.originalColumn;\n\t\n\t        if (mapping.name != null) {\n\t          nameIdx = this._names.indexOf(mapping.name);\n\t          next += base64VLQ.encode(nameIdx - previousName);\n\t          previousName = nameIdx;\n\t        }\n\t      }\n\t\n\t      result += next;\n\t    }\n\t\n\t    return result;\n\t  };\n\t\n\tSourceMapGenerator.prototype._generateSourcesContent =\n\t  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {\n\t    return aSources.map(function (source) {\n\t      if (!this._sourcesContents) {\n\t        return null;\n\t      }\n\t      if (aSourceRoot != null) {\n\t        source = util.relative(aSourceRoot, source);\n\t      }\n\t      var key = util.toSetString(source);\n\t      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)\n\t        ? this._sourcesContents[key]\n\t        : null;\n\t    }, this);\n\t  };\n\t\n\t/**\n\t * Externalize the source map.\n\t */\n\tSourceMapGenerator.prototype.toJSON =\n\t  function SourceMapGenerator_toJSON() {\n\t    var map = {\n\t      version: this._version,\n\t      sources: this._sources.toArray(),\n\t      names: this._names.toArray(),\n\t      mappings: this._serializeMappings()\n\t    };\n\t    if (this._file != null) {\n\t      map.file = this._file;\n\t    }\n\t    if (this._sourceRoot != null) {\n\t      map.sourceRoot = this._sourceRoot;\n\t    }\n\t    if (this._sourcesContents) {\n\t      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);\n\t    }\n\t\n\t    return map;\n\t  };\n\t\n\t/**\n\t * Render the source map being generated to a string.\n\t */\n\tSourceMapGenerator.prototype.toString =\n\t  function SourceMapGenerator_toString() {\n\t    return JSON.stringify(this.toJSON());\n\t  };\n\t\n\texports.SourceMapGenerator = SourceMapGenerator;\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* -*- Mode: js; js-indent-level: 2; -*- */\n\t/*\n\t * Copyright 2011 Mozilla Foundation and contributors\n\t * Licensed under the New BSD license. See LICENSE or:\n\t * http://opensource.org/licenses/BSD-3-Clause\n\t *\n\t * Based on the Base 64 VLQ implementation in Closure Compiler:\n\t * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java\n\t *\n\t * Copyright 2011 The Closure Compiler Authors. All rights reserved.\n\t * Redistribution and use in source and binary forms, with or without\n\t * modification, are permitted provided that the following conditions are\n\t * met:\n\t *\n\t *  * Redistributions of source code must retain the above copyright\n\t *    notice, this list of conditions and the following disclaimer.\n\t *  * Redistributions in binary form must reproduce the above\n\t *    copyright notice, this list of conditions and the following\n\t *    disclaimer in the documentation and/or other materials provided\n\t *    with the distribution.\n\t *  * Neither the name of Google Inc. nor the names of its\n\t *    contributors may be used to endorse or promote products derived\n\t *    from this software without specific prior written permission.\n\t *\n\t * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\t * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n\t * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n\t * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n\t * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n\t * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n\t * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n\t * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n\t * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\t * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n\t * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t */\n\t\n\tvar base64 = __webpack_require__(6);\n\t\n\t// A single base 64 digit can contain 6 bits of data. For the base 64 variable\n\t// length quantities we use in the source map spec, the first bit is the sign,\n\t// the next four bits are the actual value, and the 6th bit is the\n\t// continuation bit. The continuation bit tells us whether there are more\n\t// digits in this value following this digit.\n\t//\n\t//   Continuation\n\t//   |    Sign\n\t//   |    |\n\t//   V    V\n\t//   101011\n\t\n\tvar VLQ_BASE_SHIFT = 5;\n\t\n\t// binary: 100000\n\tvar VLQ_BASE = 1 << VLQ_BASE_SHIFT;\n\t\n\t// binary: 011111\n\tvar VLQ_BASE_MASK = VLQ_BASE - 1;\n\t\n\t// binary: 100000\n\tvar VLQ_CONTINUATION_BIT = VLQ_BASE;\n\t\n\t/**\n\t * Converts from a two-complement value to a value where the sign bit is\n\t * placed in the least significant bit.  For example, as decimals:\n\t *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)\n\t *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)\n\t */\n\tfunction toVLQSigned(aValue) {\n\t  return aValue < 0\n\t    ? ((-aValue) << 1) + 1\n\t    : (aValue << 1) + 0;\n\t}\n\t\n\t/**\n\t * Converts to a two-complement value from a value where the sign bit is\n\t * placed in the least significant bit.  For example, as decimals:\n\t *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1\n\t *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2\n\t */\n\tfunction fromVLQSigned(aValue) {\n\t  var isNegative = (aValue & 1) === 1;\n\t  var shifted = aValue >> 1;\n\t  return isNegative\n\t    ? -shifted\n\t    : shifted;\n\t}\n\t\n\t/**\n\t * Returns the base 64 VLQ encoded value.\n\t */\n\texports.encode = function base64VLQ_encode(aValue) {\n\t  var encoded = \"\";\n\t  var digit;\n\t\n\t  var vlq = toVLQSigned(aValue);\n\t\n\t  do {\n\t    digit = vlq & VLQ_BASE_MASK;\n\t    vlq >>>= VLQ_BASE_SHIFT;\n\t    if (vlq > 0) {\n\t      // There are still more digits in this value, so we must make sure the\n\t      // continuation bit is marked.\n\t      digit |= VLQ_CONTINUATION_BIT;\n\t    }\n\t    encoded += base64.encode(digit);\n\t  } while (vlq > 0);\n\t\n\t  return encoded;\n\t};\n\t\n\t/**\n\t * Decodes the next base 64 VLQ value from the given string and returns the\n\t * value and the rest of the string via the out parameter.\n\t */\n\texports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {\n\t  var strLen = aStr.length;\n\t  var result = 0;\n\t  var shift = 0;\n\t  var continuation, digit;\n\t\n\t  do {\n\t    if (aIndex >= strLen) {\n\t      throw new Error(\"Expected more digits in base 64 VLQ value.\");\n\t    }\n\t\n\t    digit = base64.decode(aStr.charCodeAt(aIndex++));\n\t    if (digit === -1) {\n\t      throw new Error(\"Invalid base64 digit: \" + aStr.charAt(aIndex - 1));\n\t    }\n\t\n\t    continuation = !!(digit & VLQ_CONTINUATION_BIT);\n\t    digit &= VLQ_BASE_MASK;\n\t    result = result + (digit << shift);\n\t    shift += VLQ_BASE_SHIFT;\n\t  } while (continuation);\n\t\n\t  aOutParam.value = fromVLQSigned(result);\n\t  aOutParam.rest = aIndex;\n\t};\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports) {\n\n\t/* -*- Mode: js; js-indent-level: 2; -*- */\n\t/*\n\t * Copyright 2011 Mozilla Foundation and contributors\n\t * Licensed under the New BSD license. See LICENSE or:\n\t * http://opensource.org/licenses/BSD-3-Clause\n\t */\n\t\n\tvar intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');\n\t\n\t/**\n\t * Encode an integer in the range of 0 to 63 to a single base 64 digit.\n\t */\n\texports.encode = function (number) {\n\t  if (0 <= number && number < intToCharMap.length) {\n\t    return intToCharMap[number];\n\t  }\n\t  throw new TypeError(\"Must be between 0 and 63: \" + number);\n\t};\n\t\n\t/**\n\t * Decode a single base 64 character code digit to an integer. Returns -1 on\n\t * failure.\n\t */\n\texports.decode = function (charCode) {\n\t  var bigA = 65;     // 'A'\n\t  var bigZ = 90;     // 'Z'\n\t\n\t  var littleA = 97;  // 'a'\n\t  var littleZ = 122; // 'z'\n\t\n\t  var zero = 48;     // '0'\n\t  var nine = 57;     // '9'\n\t\n\t  var plus = 43;     // '+'\n\t  var slash = 47;    // '/'\n\t\n\t  var littleOffset = 26;\n\t  var numberOffset = 52;\n\t\n\t  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ\n\t  if (bigA <= charCode && charCode <= bigZ) {\n\t    return (charCode - bigA);\n\t  }\n\t\n\t  // 26 - 51: abcdefghijklmnopqrstuvwxyz\n\t  if (littleA <= charCode && charCode <= littleZ) {\n\t    return (charCode - littleA + littleOffset);\n\t  }\n\t\n\t  // 52 - 61: 0123456789\n\t  if (zero <= charCode && charCode <= nine) {\n\t    return (charCode - zero + numberOffset);\n\t  }\n\t\n\t  // 62: +\n\t  if (charCode == plus) {\n\t    return 62;\n\t  }\n\t\n\t  // 63: /\n\t  if (charCode == slash) {\n\t    return 63;\n\t  }\n\t\n\t  // Invalid base64 digit.\n\t  return -1;\n\t};\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports) {\n\n\t/* -*- Mode: js; js-indent-level: 2; -*- */\n\t/*\n\t * Copyright 2011 Mozilla Foundation and contributors\n\t * Licensed under the New BSD license. See LICENSE or:\n\t * http://opensource.org/licenses/BSD-3-Clause\n\t */\n\t\n\t/**\n\t * This is a helper function for getting values from parameter/options\n\t * objects.\n\t *\n\t * @param args The object we are extracting values from\n\t * @param name The name of the property we are getting.\n\t * @param defaultValue An optional value to return if the property is missing\n\t * from the object. If this is not specified and the property is missing, an\n\t * error will be thrown.\n\t */\n\tfunction getArg(aArgs, aName, aDefaultValue) {\n\t  if (aName in aArgs) {\n\t    return aArgs[aName];\n\t  } else if (arguments.length === 3) {\n\t    return aDefaultValue;\n\t  } else {\n\t    throw new Error('\"' + aName + '\" is a required argument.');\n\t  }\n\t}\n\texports.getArg = getArg;\n\t\n\tvar urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.]*)(?::(\\d+))?(\\S*)$/;\n\tvar dataUrlRegexp = /^data:.+\\,.+$/;\n\t\n\tfunction urlParse(aUrl) {\n\t  var match = aUrl.match(urlRegexp);\n\t  if (!match) {\n\t    return null;\n\t  }\n\t  return {\n\t    scheme: match[1],\n\t    auth: match[2],\n\t    host: match[3],\n\t    port: match[4],\n\t    path: match[5]\n\t  };\n\t}\n\texports.urlParse = urlParse;\n\t\n\tfunction urlGenerate(aParsedUrl) {\n\t  var url = '';\n\t  if (aParsedUrl.scheme) {\n\t    url += aParsedUrl.scheme + ':';\n\t  }\n\t  url += '//';\n\t  if (aParsedUrl.auth) {\n\t    url += aParsedUrl.auth + '@';\n\t  }\n\t  if (aParsedUrl.host) {\n\t    url += aParsedUrl.host;\n\t  }\n\t  if (aParsedUrl.port) {\n\t    url += \":\" + aParsedUrl.port\n\t  }\n\t  if (aParsedUrl.path) {\n\t    url += aParsedUrl.path;\n\t  }\n\t  return url;\n\t}\n\texports.urlGenerate = urlGenerate;\n\t\n\t/**\n\t * Normalizes a path, or the path portion of a URL:\n\t *\n\t * - Replaces consecutive slashes with one slash.\n\t * - Removes unnecessary '.' parts.\n\t * - Removes unnecessary '<dir>/..' parts.\n\t *\n\t * Based on code in the Node.js 'path' core module.\n\t *\n\t * @param aPath The path or url to normalize.\n\t */\n\tfunction normalize(aPath) {\n\t  var path = aPath;\n\t  var url = urlParse(aPath);\n\t  if (url) {\n\t    if (!url.path) {\n\t      return aPath;\n\t    }\n\t    path = url.path;\n\t  }\n\t  var isAbsolute = exports.isAbsolute(path);\n\t\n\t  var parts = path.split(/\\/+/);\n\t  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {\n\t    part = parts[i];\n\t    if (part === '.') {\n\t      parts.splice(i, 1);\n\t    } else if (part === '..') {\n\t      up++;\n\t    } else if (up > 0) {\n\t      if (part === '') {\n\t        // The first part is blank if the path is absolute. Trying to go\n\t        // above the root is a no-op. Therefore we can remove all '..' parts\n\t        // directly after the root.\n\t        parts.splice(i + 1, up);\n\t        up = 0;\n\t      } else {\n\t        parts.splice(i, 2);\n\t        up--;\n\t      }\n\t    }\n\t  }\n\t  path = parts.join('/');\n\t\n\t  if (path === '') {\n\t    path = isAbsolute ? '/' : '.';\n\t  }\n\t\n\t  if (url) {\n\t    url.path = path;\n\t    return urlGenerate(url);\n\t  }\n\t  return path;\n\t}\n\texports.normalize = normalize;\n\t\n\t/**\n\t * Joins two paths/URLs.\n\t *\n\t * @param aRoot The root path or URL.\n\t * @param aPath The path or URL to be joined with the root.\n\t *\n\t * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a\n\t *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended\n\t *   first.\n\t * - Otherwise aPath is a path. If aRoot is a URL, then its path portion\n\t *   is updated with the result and aRoot is returned. Otherwise the result\n\t *   is returned.\n\t *   - If aPath is absolute, the result is aPath.\n\t *   - Otherwise the two paths are joined with a slash.\n\t * - Joining for example 'http://' and 'www.example.com' is also supported.\n\t */\n\tfunction join(aRoot, aPath) {\n\t  if (aRoot === \"\") {\n\t    aRoot = \".\";\n\t  }\n\t  if (aPath === \"\") {\n\t    aPath = \".\";\n\t  }\n\t  var aPathUrl = urlParse(aPath);\n\t  var aRootUrl = urlParse(aRoot);\n\t  if (aRootUrl) {\n\t    aRoot = aRootUrl.path || '/';\n\t  }\n\t\n\t  // `join(foo, '//www.example.org')`\n\t  if (aPathUrl && !aPathUrl.scheme) {\n\t    if (aRootUrl) {\n\t      aPathUrl.scheme = aRootUrl.scheme;\n\t    }\n\t    return urlGenerate(aPathUrl);\n\t  }\n\t\n\t  if (aPathUrl || aPath.match(dataUrlRegexp)) {\n\t    return aPath;\n\t  }\n\t\n\t  // `join('http://', 'www.example.com')`\n\t  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n\t    aRootUrl.host = aPath;\n\t    return urlGenerate(aRootUrl);\n\t  }\n\t\n\t  var joined = aPath.charAt(0) === '/'\n\t    ? aPath\n\t    : normalize(aRoot.replace(/\\/+$/, '') + '/' + aPath);\n\t\n\t  if (aRootUrl) {\n\t    aRootUrl.path = joined;\n\t    return urlGenerate(aRootUrl);\n\t  }\n\t  return joined;\n\t}\n\texports.join = join;\n\t\n\texports.isAbsolute = function (aPath) {\n\t  return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp);\n\t};\n\t\n\t/**\n\t * Make a path relative to a URL or another path.\n\t *\n\t * @param aRoot The root path or URL.\n\t * @param aPath The path or URL to be made relative to aRoot.\n\t */\n\tfunction relative(aRoot, aPath) {\n\t  if (aRoot === \"\") {\n\t    aRoot = \".\";\n\t  }\n\t\n\t  aRoot = aRoot.replace(/\\/$/, '');\n\t\n\t  // It is possible for the path to be above the root. In this case, simply\n\t  // checking whether the root is a prefix of the path won't work. Instead, we\n\t  // need to remove components from the root one by one, until either we find\n\t  // a prefix that fits, or we run out of components to remove.\n\t  var level = 0;\n\t  while (aPath.indexOf(aRoot + '/') !== 0) {\n\t    var index = aRoot.lastIndexOf(\"/\");\n\t    if (index < 0) {\n\t      return aPath;\n\t    }\n\t\n\t    // If the only part of the root that is left is the scheme (i.e. http://,\n\t    // file:///, etc.), one or more slashes (/), or simply nothing at all, we\n\t    // have exhausted all components, so the path is not relative to the root.\n\t    aRoot = aRoot.slice(0, index);\n\t    if (aRoot.match(/^([^\\/]+:\\/)?\\/*$/)) {\n\t      return aPath;\n\t    }\n\t\n\t    ++level;\n\t  }\n\t\n\t  // Make sure we add a \"../\" for each component we removed from the root.\n\t  return Array(level + 1).join(\"../\") + aPath.substr(aRoot.length + 1);\n\t}\n\texports.relative = relative;\n\t\n\tvar supportsNullProto = (function () {\n\t  var obj = Object.create(null);\n\t  return !('__proto__' in obj);\n\t}());\n\t\n\tfunction identity (s) {\n\t  return s;\n\t}\n\t\n\t/**\n\t * Because behavior goes wacky when you set `__proto__` on objects, we\n\t * have to prefix all the strings in our set with an arbitrary character.\n\t *\n\t * See https://github.com/mozilla/source-map/pull/31 and\n\t * https://github.com/mozilla/source-map/issues/30\n\t *\n\t * @param String aStr\n\t */\n\tfunction toSetString(aStr) {\n\t  if (isProtoString(aStr)) {\n\t    return '$' + aStr;\n\t  }\n\t\n\t  return aStr;\n\t}\n\texports.toSetString = supportsNullProto ? identity : toSetString;\n\t\n\tfunction fromSetString(aStr) {\n\t  if (isProtoString(aStr)) {\n\t    return aStr.slice(1);\n\t  }\n\t\n\t  return aStr;\n\t}\n\texports.fromSetString = supportsNullProto ? identity : fromSetString;\n\t\n\tfunction isProtoString(s) {\n\t  if (!s) {\n\t    return false;\n\t  }\n\t\n\t  var length = s.length;\n\t\n\t  if (length < 9 /* \"__proto__\".length */) {\n\t    return false;\n\t  }\n\t\n\t  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||\n\t      s.charCodeAt(length - 2) !== 95  /* '_' */ ||\n\t      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||\n\t      s.charCodeAt(length - 4) !== 116 /* 't' */ ||\n\t      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||\n\t      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||\n\t      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||\n\t      s.charCodeAt(length - 8) !== 95  /* '_' */ ||\n\t      s.charCodeAt(length - 9) !== 95  /* '_' */) {\n\t    return false;\n\t  }\n\t\n\t  for (var i = length - 10; i >= 0; i--) {\n\t    if (s.charCodeAt(i) !== 36 /* '$' */) {\n\t      return false;\n\t    }\n\t  }\n\t\n\t  return true;\n\t}\n\t\n\t/**\n\t * Comparator between two mappings where the original positions are compared.\n\t *\n\t * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n\t * mappings with the same original source/line/column, but different generated\n\t * line and column the same. Useful when searching for a mapping with a\n\t * stubbed out mapping.\n\t */\n\tfunction compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n\t  var cmp = mappingA.source - mappingB.source;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\t\n\t  cmp = mappingA.originalLine - mappingB.originalLine;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\t\n\t  cmp = mappingA.originalColumn - mappingB.originalColumn;\n\t  if (cmp !== 0 || onlyCompareOriginal) {\n\t    return cmp;\n\t  }\n\t\n\t  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\t\n\t  cmp = mappingA.generatedLine - mappingB.generatedLine;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\t\n\t  return mappingA.name - mappingB.name;\n\t}\n\texports.compareByOriginalPositions = compareByOriginalPositions;\n\t\n\t/**\n\t * Comparator between two mappings with deflated source and name indices where\n\t * the generated positions are compared.\n\t *\n\t * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n\t * mappings with the same generated line and column, but different\n\t * source/name/original line and column the same. Useful when searching for a\n\t * mapping with a stubbed out mapping.\n\t */\n\tfunction compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {\n\t  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\t\n\t  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n\t  if (cmp !== 0 || onlyCompareGenerated) {\n\t    return cmp;\n\t  }\n\t\n\t  cmp = mappingA.source - mappingB.source;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\t\n\t  cmp = mappingA.originalLine - mappingB.originalLine;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\t\n\t  cmp = mappingA.originalColumn - mappingB.originalColumn;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\t\n\t  return mappingA.name - mappingB.name;\n\t}\n\texports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;\n\t\n\tfunction strcmp(aStr1, aStr2) {\n\t  if (aStr1 === aStr2) {\n\t    return 0;\n\t  }\n\t\n\t  if (aStr1 > aStr2) {\n\t    return 1;\n\t  }\n\t\n\t  return -1;\n\t}\n\t\n\t/**\n\t * Comparator between two mappings with inflated source and name strings where\n\t * the generated positions are compared.\n\t */\n\tfunction compareByGeneratedPositionsInflated(mappingA, mappingB) {\n\t  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\t\n\t  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\t\n\t  cmp = strcmp(mappingA.source, mappingB.source);\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\t\n\t  cmp = mappingA.originalLine - mappingB.originalLine;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\t\n\t  cmp = mappingA.originalColumn - mappingB.originalColumn;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\t\n\t  return strcmp(mappingA.name, mappingB.name);\n\t}\n\texports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* -*- Mode: js; js-indent-level: 2; -*- */\n\t/*\n\t * Copyright 2011 Mozilla Foundation and contributors\n\t * Licensed under the New BSD license. See LICENSE or:\n\t * http://opensource.org/licenses/BSD-3-Clause\n\t */\n\t\n\tvar util = __webpack_require__(7);\n\tvar has = Object.prototype.hasOwnProperty;\n\t\n\t/**\n\t * A data structure which is a combination of an array and a set. Adding a new\n\t * member is O(1), testing for membership is O(1), and finding the index of an\n\t * element is O(1). Removing elements from the set is not supported. Only\n\t * strings are supported for membership.\n\t */\n\tfunction ArraySet() {\n\t  this._array = [];\n\t  this._set = Object.create(null);\n\t}\n\t\n\t/**\n\t * Static method for creating ArraySet instances from an existing array.\n\t */\n\tArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {\n\t  var set = new ArraySet();\n\t  for (var i = 0, len = aArray.length; i < len; i++) {\n\t    set.add(aArray[i], aAllowDuplicates);\n\t  }\n\t  return set;\n\t};\n\t\n\t/**\n\t * Return how many unique items are in this ArraySet. If duplicates have been\n\t * added, than those do not count towards the size.\n\t *\n\t * @returns Number\n\t */\n\tArraySet.prototype.size = function ArraySet_size() {\n\t  return Object.getOwnPropertyNames(this._set).length;\n\t};\n\t\n\t/**\n\t * Add the given string to this set.\n\t *\n\t * @param String aStr\n\t */\n\tArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {\n\t  var sStr = util.toSetString(aStr);\n\t  var isDuplicate = has.call(this._set, sStr);\n\t  var idx = this._array.length;\n\t  if (!isDuplicate || aAllowDuplicates) {\n\t    this._array.push(aStr);\n\t  }\n\t  if (!isDuplicate) {\n\t    this._set[sStr] = idx;\n\t  }\n\t};\n\t\n\t/**\n\t * Is the given string a member of this set?\n\t *\n\t * @param String aStr\n\t */\n\tArraySet.prototype.has = function ArraySet_has(aStr) {\n\t  var sStr = util.toSetString(aStr);\n\t  return has.call(this._set, sStr);\n\t};\n\t\n\t/**\n\t * What is the index of the given string in the array?\n\t *\n\t * @param String aStr\n\t */\n\tArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {\n\t  var sStr = util.toSetString(aStr);\n\t  if (has.call(this._set, sStr)) {\n\t    return this._set[sStr];\n\t  }\n\t  throw new Error('\"' + aStr + '\" is not in the set.');\n\t};\n\t\n\t/**\n\t * What is the element at the given index?\n\t *\n\t * @param Number aIdx\n\t */\n\tArraySet.prototype.at = function ArraySet_at(aIdx) {\n\t  if (aIdx >= 0 && aIdx < this._array.length) {\n\t    return this._array[aIdx];\n\t  }\n\t  throw new Error('No element indexed by ' + aIdx);\n\t};\n\t\n\t/**\n\t * Returns the array representation of this set (which has the proper indices\n\t * indicated by indexOf). Note that this is a copy of the internal array used\n\t * for storing the members so that no one can mess with internal state.\n\t */\n\tArraySet.prototype.toArray = function ArraySet_toArray() {\n\t  return this._array.slice();\n\t};\n\t\n\texports.ArraySet = ArraySet;\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* -*- Mode: js; js-indent-level: 2; -*- */\n\t/*\n\t * Copyright 2014 Mozilla Foundation and contributors\n\t * Licensed under the New BSD license. See LICENSE or:\n\t * http://opensource.org/licenses/BSD-3-Clause\n\t */\n\t\n\tvar util = __webpack_require__(7);\n\t\n\t/**\n\t * Determine whether mappingB is after mappingA with respect to generated\n\t * position.\n\t */\n\tfunction generatedPositionAfter(mappingA, mappingB) {\n\t  // Optimized for most common case\n\t  var lineA = mappingA.generatedLine;\n\t  var lineB = mappingB.generatedLine;\n\t  var columnA = mappingA.generatedColumn;\n\t  var columnB = mappingB.generatedColumn;\n\t  return lineB > lineA || lineB == lineA && columnB >= columnA ||\n\t         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;\n\t}\n\t\n\t/**\n\t * A data structure to provide a sorted view of accumulated mappings in a\n\t * performance conscious manner. It trades a neglibable overhead in general\n\t * case for a large speedup in case of mappings being added in order.\n\t */\n\tfunction MappingList() {\n\t  this._array = [];\n\t  this._sorted = true;\n\t  // Serves as infimum\n\t  this._last = {generatedLine: -1, generatedColumn: 0};\n\t}\n\t\n\t/**\n\t * Iterate through internal items. This method takes the same arguments that\n\t * `Array.prototype.forEach` takes.\n\t *\n\t * NOTE: The order of the mappings is NOT guaranteed.\n\t */\n\tMappingList.prototype.unsortedForEach =\n\t  function MappingList_forEach(aCallback, aThisArg) {\n\t    this._array.forEach(aCallback, aThisArg);\n\t  };\n\t\n\t/**\n\t * Add the given source mapping.\n\t *\n\t * @param Object aMapping\n\t */\n\tMappingList.prototype.add = function MappingList_add(aMapping) {\n\t  if (generatedPositionAfter(this._last, aMapping)) {\n\t    this._last = aMapping;\n\t    this._array.push(aMapping);\n\t  } else {\n\t    this._sorted = false;\n\t    this._array.push(aMapping);\n\t  }\n\t};\n\t\n\t/**\n\t * Returns the flat, sorted array of mappings. The mappings are sorted by\n\t * generated position.\n\t *\n\t * WARNING: This method returns internal data without copying, for\n\t * performance. The return value must NOT be mutated, and should be treated as\n\t * an immutable borrow. If you want to take ownership, you must make your own\n\t * copy.\n\t */\n\tMappingList.prototype.toArray = function MappingList_toArray() {\n\t  if (!this._sorted) {\n\t    this._array.sort(util.compareByGeneratedPositionsInflated);\n\t    this._sorted = true;\n\t  }\n\t  return this._array;\n\t};\n\t\n\texports.MappingList = MappingList;\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* -*- Mode: js; js-indent-level: 2; -*- */\n\t/*\n\t * Copyright 2011 Mozilla Foundation and contributors\n\t * Licensed under the New BSD license. See LICENSE or:\n\t * http://opensource.org/licenses/BSD-3-Clause\n\t */\n\t\n\tvar util = __webpack_require__(7);\n\tvar binarySearch = __webpack_require__(11);\n\tvar ArraySet = __webpack_require__(8).ArraySet;\n\tvar base64VLQ = __webpack_require__(5);\n\tvar quickSort = __webpack_require__(12).quickSort;\n\t\n\tfunction SourceMapConsumer(aSourceMap) {\n\t  var sourceMap = aSourceMap;\n\t  if (typeof aSourceMap === 'string') {\n\t    sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n\t  }\n\t\n\t  return sourceMap.sections != null\n\t    ? new IndexedSourceMapConsumer(sourceMap)\n\t    : new BasicSourceMapConsumer(sourceMap);\n\t}\n\t\n\tSourceMapConsumer.fromSourceMap = function(aSourceMap) {\n\t  return BasicSourceMapConsumer.fromSourceMap(aSourceMap);\n\t}\n\t\n\t/**\n\t * The version of the source mapping spec that we are consuming.\n\t */\n\tSourceMapConsumer.prototype._version = 3;\n\t\n\t// `__generatedMappings` and `__originalMappings` are arrays that hold the\n\t// parsed mapping coordinates from the source map's \"mappings\" attribute. They\n\t// are lazily instantiated, accessed via the `_generatedMappings` and\n\t// `_originalMappings` getters respectively, and we only parse the mappings\n\t// and create these arrays once queried for a source location. We jump through\n\t// these hoops because there can be many thousands of mappings, and parsing\n\t// them is expensive, so we only want to do it if we must.\n\t//\n\t// Each object in the arrays is of the form:\n\t//\n\t//     {\n\t//       generatedLine: The line number in the generated code,\n\t//       generatedColumn: The column number in the generated code,\n\t//       source: The path to the original source file that generated this\n\t//               chunk of code,\n\t//       originalLine: The line number in the original source that\n\t//                     corresponds to this chunk of generated code,\n\t//       originalColumn: The column number in the original source that\n\t//                       corresponds to this chunk of generated code,\n\t//       name: The name of the original symbol which generated this chunk of\n\t//             code.\n\t//     }\n\t//\n\t// All properties except for `generatedLine` and `generatedColumn` can be\n\t// `null`.\n\t//\n\t// `_generatedMappings` is ordered by the generated positions.\n\t//\n\t// `_originalMappings` is ordered by the original positions.\n\t\n\tSourceMapConsumer.prototype.__generatedMappings = null;\n\tObject.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {\n\t  get: function () {\n\t    if (!this.__generatedMappings) {\n\t      this._parseMappings(this._mappings, this.sourceRoot);\n\t    }\n\t\n\t    return this.__generatedMappings;\n\t  }\n\t});\n\t\n\tSourceMapConsumer.prototype.__originalMappings = null;\n\tObject.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {\n\t  get: function () {\n\t    if (!this.__originalMappings) {\n\t      this._parseMappings(this._mappings, this.sourceRoot);\n\t    }\n\t\n\t    return this.__originalMappings;\n\t  }\n\t});\n\t\n\tSourceMapConsumer.prototype._charIsMappingSeparator =\n\t  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {\n\t    var c = aStr.charAt(index);\n\t    return c === \";\" || c === \",\";\n\t  };\n\t\n\t/**\n\t * Parse the mappings in a string in to a data structure which we can easily\n\t * query (the ordered arrays in the `this.__generatedMappings` and\n\t * `this.__originalMappings` properties).\n\t */\n\tSourceMapConsumer.prototype._parseMappings =\n\t  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n\t    throw new Error(\"Subclasses must implement _parseMappings\");\n\t  };\n\t\n\tSourceMapConsumer.GENERATED_ORDER = 1;\n\tSourceMapConsumer.ORIGINAL_ORDER = 2;\n\t\n\tSourceMapConsumer.GREATEST_LOWER_BOUND = 1;\n\tSourceMapConsumer.LEAST_UPPER_BOUND = 2;\n\t\n\t/**\n\t * Iterate over each mapping between an original source/line/column and a\n\t * generated line/column in this source map.\n\t *\n\t * @param Function aCallback\n\t *        The function that is called with each mapping.\n\t * @param Object aContext\n\t *        Optional. If specified, this object will be the value of `this` every\n\t *        time that `aCallback` is called.\n\t * @param aOrder\n\t *        Either `SourceMapConsumer.GENERATED_ORDER` or\n\t *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n\t *        iterate over the mappings sorted by the generated file's line/column\n\t *        order or the original's source/line/column order, respectively. Defaults to\n\t *        `SourceMapConsumer.GENERATED_ORDER`.\n\t */\n\tSourceMapConsumer.prototype.eachMapping =\n\t  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {\n\t    var context = aContext || null;\n\t    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n\t\n\t    var mappings;\n\t    switch (order) {\n\t    case SourceMapConsumer.GENERATED_ORDER:\n\t      mappings = this._generatedMappings;\n\t      break;\n\t    case SourceMapConsumer.ORIGINAL_ORDER:\n\t      mappings = this._originalMappings;\n\t      break;\n\t    default:\n\t      throw new Error(\"Unknown order of iteration.\");\n\t    }\n\t\n\t    var sourceRoot = this.sourceRoot;\n\t    mappings.map(function (mapping) {\n\t      var source = mapping.source === null ? null : this._sources.at(mapping.source);\n\t      if (source != null && sourceRoot != null) {\n\t        source = util.join(sourceRoot, source);\n\t      }\n\t      return {\n\t        source: source,\n\t        generatedLine: mapping.generatedLine,\n\t        generatedColumn: mapping.generatedColumn,\n\t        originalLine: mapping.originalLine,\n\t        originalColumn: mapping.originalColumn,\n\t        name: mapping.name === null ? null : this._names.at(mapping.name)\n\t      };\n\t    }, this).forEach(aCallback, context);\n\t  };\n\t\n\t/**\n\t * Returns all generated line and column information for the original source,\n\t * line, and column provided. If no column is provided, returns all mappings\n\t * corresponding to a either the line we are searching for or the next\n\t * closest line that has any mappings. Otherwise, returns all mappings\n\t * corresponding to the given line and either the column we are searching for\n\t * or the next closest column that has any offsets.\n\t *\n\t * The only argument is an object with the following properties:\n\t *\n\t *   - source: The filename of the original source.\n\t *   - line: The line number in the original source.\n\t *   - column: Optional. the column number in the original source.\n\t *\n\t * and an array of objects is returned, each with the following properties:\n\t *\n\t *   - line: The line number in the generated source, or null.\n\t *   - column: The column number in the generated source, or null.\n\t */\n\tSourceMapConsumer.prototype.allGeneratedPositionsFor =\n\t  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {\n\t    var line = util.getArg(aArgs, 'line');\n\t\n\t    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping\n\t    // returns the index of the closest mapping less than the needle. By\n\t    // setting needle.originalColumn to 0, we thus find the last mapping for\n\t    // the given line, provided such a mapping exists.\n\t    var needle = {\n\t      source: util.getArg(aArgs, 'source'),\n\t      originalLine: line,\n\t      originalColumn: util.getArg(aArgs, 'column', 0)\n\t    };\n\t\n\t    if (this.sourceRoot != null) {\n\t      needle.source = util.relative(this.sourceRoot, needle.source);\n\t    }\n\t    if (!this._sources.has(needle.source)) {\n\t      return [];\n\t    }\n\t    needle.source = this._sources.indexOf(needle.source);\n\t\n\t    var mappings = [];\n\t\n\t    var index = this._findMapping(needle,\n\t                                  this._originalMappings,\n\t                                  \"originalLine\",\n\t                                  \"originalColumn\",\n\t                                  util.compareByOriginalPositions,\n\t                                  binarySearch.LEAST_UPPER_BOUND);\n\t    if (index >= 0) {\n\t      var mapping = this._originalMappings[index];\n\t\n\t      if (aArgs.column === undefined) {\n\t        var originalLine = mapping.originalLine;\n\t\n\t        // Iterate until either we run out of mappings, or we run into\n\t        // a mapping for a different line than the one we found. Since\n\t        // mappings are sorted, this is guaranteed to find all mappings for\n\t        // the line we found.\n\t        while (mapping && mapping.originalLine === originalLine) {\n\t          mappings.push({\n\t            line: util.getArg(mapping, 'generatedLine', null),\n\t            column: util.getArg(mapping, 'generatedColumn', null),\n\t            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n\t          });\n\t\n\t          mapping = this._originalMappings[++index];\n\t        }\n\t      } else {\n\t        var originalColumn = mapping.originalColumn;\n\t\n\t        // Iterate until either we run out of mappings, or we run into\n\t        // a mapping for a different line than the one we were searching for.\n\t        // Since mappings are sorted, this is guaranteed to find all mappings for\n\t        // the line we are searching for.\n\t        while (mapping &&\n\t               mapping.originalLine === line &&\n\t               mapping.originalColumn == originalColumn) {\n\t          mappings.push({\n\t            line: util.getArg(mapping, 'generatedLine', null),\n\t            column: util.getArg(mapping, 'generatedColumn', null),\n\t            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n\t          });\n\t\n\t          mapping = this._originalMappings[++index];\n\t        }\n\t      }\n\t    }\n\t\n\t    return mappings;\n\t  };\n\t\n\texports.SourceMapConsumer = SourceMapConsumer;\n\t\n\t/**\n\t * A BasicSourceMapConsumer instance represents a parsed source map which we can\n\t * query for information about the original file positions by giving it a file\n\t * position in the generated source.\n\t *\n\t * The only parameter is the raw source map (either as a JSON string, or\n\t * already parsed to an object). According to the spec, source maps have the\n\t * following attributes:\n\t *\n\t *   - version: Which version of the source map spec this map is following.\n\t *   - sources: An array of URLs to the original source files.\n\t *   - names: An array of identifiers which can be referrenced by individual mappings.\n\t *   - sourceRoot: Optional. The URL root from which all sources are relative.\n\t *   - sourcesContent: Optional. An array of contents of the original source files.\n\t *   - mappings: A string of base64 VLQs which contain the actual mappings.\n\t *   - file: Optional. The generated file this source map is associated with.\n\t *\n\t * Here is an example source map, taken from the source map spec[0]:\n\t *\n\t *     {\n\t *       version : 3,\n\t *       file: \"out.js\",\n\t *       sourceRoot : \"\",\n\t *       sources: [\"foo.js\", \"bar.js\"],\n\t *       names: [\"src\", \"maps\", \"are\", \"fun\"],\n\t *       mappings: \"AA,AB;;ABCDE;\"\n\t *     }\n\t *\n\t * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n\t */\n\tfunction BasicSourceMapConsumer(aSourceMap) {\n\t  var sourceMap = aSourceMap;\n\t  if (typeof aSourceMap === 'string') {\n\t    sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n\t  }\n\t\n\t  var version = util.getArg(sourceMap, 'version');\n\t  var sources = util.getArg(sourceMap, 'sources');\n\t  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\n\t  // requires the array) to play nice here.\n\t  var names = util.getArg(sourceMap, 'names', []);\n\t  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);\n\t  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);\n\t  var mappings = util.getArg(sourceMap, 'mappings');\n\t  var file = util.getArg(sourceMap, 'file', null);\n\t\n\t  // Once again, Sass deviates from the spec and supplies the version as a\n\t  // string rather than a number, so we use loose equality checking here.\n\t  if (version != this._version) {\n\t    throw new Error('Unsupported version: ' + version);\n\t  }\n\t\n\t  sources = sources\n\t    .map(String)\n\t    // Some source maps produce relative source paths like \"./foo.js\" instead of\n\t    // \"foo.js\".  Normalize these first so that future comparisons will succeed.\n\t    // See bugzil.la/1090768.\n\t    .map(util.normalize)\n\t    // Always ensure that absolute sources are internally stored relative to\n\t    // the source root, if the source root is absolute. Not doing this would\n\t    // be particularly problematic when the source root is a prefix of the\n\t    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.\n\t    .map(function (source) {\n\t      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)\n\t        ? util.relative(sourceRoot, source)\n\t        : source;\n\t    });\n\t\n\t  // Pass `true` below to allow duplicate names and sources. While source maps\n\t  // are intended to be compressed and deduplicated, the TypeScript compiler\n\t  // sometimes generates source maps with duplicates in them. See Github issue\n\t  // #72 and bugzil.la/889492.\n\t  this._names = ArraySet.fromArray(names.map(String), true);\n\t  this._sources = ArraySet.fromArray(sources, true);\n\t\n\t  this.sourceRoot = sourceRoot;\n\t  this.sourcesContent = sourcesContent;\n\t  this._mappings = mappings;\n\t  this.file = file;\n\t}\n\t\n\tBasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\n\tBasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;\n\t\n\t/**\n\t * Create a BasicSourceMapConsumer from a SourceMapGenerator.\n\t *\n\t * @param SourceMapGenerator aSourceMap\n\t *        The source map that will be consumed.\n\t * @returns BasicSourceMapConsumer\n\t */\n\tBasicSourceMapConsumer.fromSourceMap =\n\t  function SourceMapConsumer_fromSourceMap(aSourceMap) {\n\t    var smc = Object.create(BasicSourceMapConsumer.prototype);\n\t\n\t    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);\n\t    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);\n\t    smc.sourceRoot = aSourceMap._sourceRoot;\n\t    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),\n\t                                                            smc.sourceRoot);\n\t    smc.file = aSourceMap._file;\n\t\n\t    // Because we are modifying the entries (by converting string sources and\n\t    // names to indices into the sources and names ArraySets), we have to make\n\t    // a copy of the entry or else bad things happen. Shared mutable state\n\t    // strikes again! See github issue #191.\n\t\n\t    var generatedMappings = aSourceMap._mappings.toArray().slice();\n\t    var destGeneratedMappings = smc.__generatedMappings = [];\n\t    var destOriginalMappings = smc.__originalMappings = [];\n\t\n\t    for (var i = 0, length = generatedMappings.length; i < length; i++) {\n\t      var srcMapping = generatedMappings[i];\n\t      var destMapping = new Mapping;\n\t      destMapping.generatedLine = srcMapping.generatedLine;\n\t      destMapping.generatedColumn = srcMapping.generatedColumn;\n\t\n\t      if (srcMapping.source) {\n\t        destMapping.source = sources.indexOf(srcMapping.source);\n\t        destMapping.originalLine = srcMapping.originalLine;\n\t        destMapping.originalColumn = srcMapping.originalColumn;\n\t\n\t        if (srcMapping.name) {\n\t          destMapping.name = names.indexOf(srcMapping.name);\n\t        }\n\t\n\t        destOriginalMappings.push(destMapping);\n\t      }\n\t\n\t      destGeneratedMappings.push(destMapping);\n\t    }\n\t\n\t    quickSort(smc.__originalMappings, util.compareByOriginalPositions);\n\t\n\t    return smc;\n\t  };\n\t\n\t/**\n\t * The version of the source mapping spec that we are consuming.\n\t */\n\tBasicSourceMapConsumer.prototype._version = 3;\n\t\n\t/**\n\t * The list of original sources.\n\t */\n\tObject.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {\n\t  get: function () {\n\t    return this._sources.toArray().map(function (s) {\n\t      return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;\n\t    }, this);\n\t  }\n\t});\n\t\n\t/**\n\t * Provide the JIT with a nice shape / hidden class.\n\t */\n\tfunction Mapping() {\n\t  this.generatedLine = 0;\n\t  this.generatedColumn = 0;\n\t  this.source = null;\n\t  this.originalLine = null;\n\t  this.originalColumn = null;\n\t  this.name = null;\n\t}\n\t\n\t/**\n\t * Parse the mappings in a string in to a data structure which we can easily\n\t * query (the ordered arrays in the `this.__generatedMappings` and\n\t * `this.__originalMappings` properties).\n\t */\n\tBasicSourceMapConsumer.prototype._parseMappings =\n\t  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n\t    var generatedLine = 1;\n\t    var previousGeneratedColumn = 0;\n\t    var previousOriginalLine = 0;\n\t    var previousOriginalColumn = 0;\n\t    var previousSource = 0;\n\t    var previousName = 0;\n\t    var length = aStr.length;\n\t    var index = 0;\n\t    var cachedSegments = {};\n\t    var temp = {};\n\t    var originalMappings = [];\n\t    var generatedMappings = [];\n\t    var mapping, str, segment, end, value;\n\t\n\t    while (index < length) {\n\t      if (aStr.charAt(index) === ';') {\n\t        generatedLine++;\n\t        index++;\n\t        previousGeneratedColumn = 0;\n\t      }\n\t      else if (aStr.charAt(index) === ',') {\n\t        index++;\n\t      }\n\t      else {\n\t        mapping = new Mapping();\n\t        mapping.generatedLine = generatedLine;\n\t\n\t        // Because each offset is encoded relative to the previous one,\n\t        // many segments often have the same encoding. We can exploit this\n\t        // fact by caching the parsed variable length fields of each segment,\n\t        // allowing us to avoid a second parse if we encounter the same\n\t        // segment again.\n\t        for (end = index; end < length; end++) {\n\t          if (this._charIsMappingSeparator(aStr, end)) {\n\t            break;\n\t          }\n\t        }\n\t        str = aStr.slice(index, end);\n\t\n\t        segment = cachedSegments[str];\n\t        if (segment) {\n\t          index += str.length;\n\t        } else {\n\t          segment = [];\n\t          while (index < end) {\n\t            base64VLQ.decode(aStr, index, temp);\n\t            value = temp.value;\n\t            index = temp.rest;\n\t            segment.push(value);\n\t          }\n\t\n\t          if (segment.length === 2) {\n\t            throw new Error('Found a source, but no line and column');\n\t          }\n\t\n\t          if (segment.length === 3) {\n\t            throw new Error('Found a source and line, but no column');\n\t          }\n\t\n\t          cachedSegments[str] = segment;\n\t        }\n\t\n\t        // Generated column.\n\t        mapping.generatedColumn = previousGeneratedColumn + segment[0];\n\t        previousGeneratedColumn = mapping.generatedColumn;\n\t\n\t        if (segment.length > 1) {\n\t          // Original source.\n\t          mapping.source = previousSource + segment[1];\n\t          previousSource += segment[1];\n\t\n\t          // Original line.\n\t          mapping.originalLine = previousOriginalLine + segment[2];\n\t          previousOriginalLine = mapping.originalLine;\n\t          // Lines are stored 0-based\n\t          mapping.originalLine += 1;\n\t\n\t          // Original column.\n\t          mapping.originalColumn = previousOriginalColumn + segment[3];\n\t          previousOriginalColumn = mapping.originalColumn;\n\t\n\t          if (segment.length > 4) {\n\t            // Original name.\n\t            mapping.name = previousName + segment[4];\n\t            previousName += segment[4];\n\t          }\n\t        }\n\t\n\t        generatedMappings.push(mapping);\n\t        if (typeof mapping.originalLine === 'number') {\n\t          originalMappings.push(mapping);\n\t        }\n\t      }\n\t    }\n\t\n\t    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);\n\t    this.__generatedMappings = generatedMappings;\n\t\n\t    quickSort(originalMappings, util.compareByOriginalPositions);\n\t    this.__originalMappings = originalMappings;\n\t  };\n\t\n\t/**\n\t * Find the mapping that best matches the hypothetical \"needle\" mapping that\n\t * we are searching for in the given \"haystack\" of mappings.\n\t */\n\tBasicSourceMapConsumer.prototype._findMapping =\n\t  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,\n\t                                         aColumnName, aComparator, aBias) {\n\t    // To return the position we are searching for, we must first find the\n\t    // mapping for the given position and then return the opposite position it\n\t    // points to. Because the mappings are sorted, we can use binary search to\n\t    // find the best mapping.\n\t\n\t    if (aNeedle[aLineName] <= 0) {\n\t      throw new TypeError('Line must be greater than or equal to 1, got '\n\t                          + aNeedle[aLineName]);\n\t    }\n\t    if (aNeedle[aColumnName] < 0) {\n\t      throw new TypeError('Column must be greater than or equal to 0, got '\n\t                          + aNeedle[aColumnName]);\n\t    }\n\t\n\t    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);\n\t  };\n\t\n\t/**\n\t * Compute the last column for each generated mapping. The last column is\n\t * inclusive.\n\t */\n\tBasicSourceMapConsumer.prototype.computeColumnSpans =\n\t  function SourceMapConsumer_computeColumnSpans() {\n\t    for (var index = 0; index < this._generatedMappings.length; ++index) {\n\t      var mapping = this._generatedMappings[index];\n\t\n\t      // Mappings do not contain a field for the last generated columnt. We\n\t      // can come up with an optimistic estimate, however, by assuming that\n\t      // mappings are contiguous (i.e. given two consecutive mappings, the\n\t      // first mapping ends where the second one starts).\n\t      if (index + 1 < this._generatedMappings.length) {\n\t        var nextMapping = this._generatedMappings[index + 1];\n\t\n\t        if (mapping.generatedLine === nextMapping.generatedLine) {\n\t          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;\n\t          continue;\n\t        }\n\t      }\n\t\n\t      // The last mapping for each line spans the entire line.\n\t      mapping.lastGeneratedColumn = Infinity;\n\t    }\n\t  };\n\t\n\t/**\n\t * Returns the original source, line, and column information for the generated\n\t * source's line and column positions provided. The only argument is an object\n\t * with the following properties:\n\t *\n\t *   - line: The line number in the generated source.\n\t *   - column: The column number in the generated source.\n\t *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n\t *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n\t *     closest element that is smaller than or greater than the one we are\n\t *     searching for, respectively, if the exact element cannot be found.\n\t *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n\t *\n\t * and an object is returned with the following properties:\n\t *\n\t *   - source: The original source file, or null.\n\t *   - line: The line number in the original source, or null.\n\t *   - column: The column number in the original source, or null.\n\t *   - name: The original identifier, or null.\n\t */\n\tBasicSourceMapConsumer.prototype.originalPositionFor =\n\t  function SourceMapConsumer_originalPositionFor(aArgs) {\n\t    var needle = {\n\t      generatedLine: util.getArg(aArgs, 'line'),\n\t      generatedColumn: util.getArg(aArgs, 'column')\n\t    };\n\t\n\t    var index = this._findMapping(\n\t      needle,\n\t      this._generatedMappings,\n\t      \"generatedLine\",\n\t      \"generatedColumn\",\n\t      util.compareByGeneratedPositionsDeflated,\n\t      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\n\t    );\n\t\n\t    if (index >= 0) {\n\t      var mapping = this._generatedMappings[index];\n\t\n\t      if (mapping.generatedLine === needle.generatedLine) {\n\t        var source = util.getArg(mapping, 'source', null);\n\t        if (source !== null) {\n\t          source = this._sources.at(source);\n\t          if (this.sourceRoot != null) {\n\t            source = util.join(this.sourceRoot, source);\n\t          }\n\t        }\n\t        var name = util.getArg(mapping, 'name', null);\n\t        if (name !== null) {\n\t          name = this._names.at(name);\n\t        }\n\t        return {\n\t          source: source,\n\t          line: util.getArg(mapping, 'originalLine', null),\n\t          column: util.getArg(mapping, 'originalColumn', null),\n\t          name: name\n\t        };\n\t      }\n\t    }\n\t\n\t    return {\n\t      source: null,\n\t      line: null,\n\t      column: null,\n\t      name: null\n\t    };\n\t  };\n\t\n\t/**\n\t * Return true if we have the source content for every source in the source\n\t * map, false otherwise.\n\t */\n\tBasicSourceMapConsumer.prototype.hasContentsOfAllSources =\n\t  function BasicSourceMapConsumer_hasContentsOfAllSources() {\n\t    if (!this.sourcesContent) {\n\t      return false;\n\t    }\n\t    return this.sourcesContent.length >= this._sources.size() &&\n\t      !this.sourcesContent.some(function (sc) { return sc == null; });\n\t  };\n\t\n\t/**\n\t * Returns the original source content. The only argument is the url of the\n\t * original source file. Returns null if no original source content is\n\t * available.\n\t */\n\tBasicSourceMapConsumer.prototype.sourceContentFor =\n\t  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n\t    if (!this.sourcesContent) {\n\t      return null;\n\t    }\n\t\n\t    if (this.sourceRoot != null) {\n\t      aSource = util.relative(this.sourceRoot, aSource);\n\t    }\n\t\n\t    if (this._sources.has(aSource)) {\n\t      return this.sourcesContent[this._sources.indexOf(aSource)];\n\t    }\n\t\n\t    var url;\n\t    if (this.sourceRoot != null\n\t        && (url = util.urlParse(this.sourceRoot))) {\n\t      // XXX: file:// URIs and absolute paths lead to unexpected behavior for\n\t      // many users. We can help them out when they expect file:// URIs to\n\t      // behave like it would if they were running a local HTTP server. See\n\t      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.\n\t      var fileUriAbsPath = aSource.replace(/^file:\\/\\//, \"\");\n\t      if (url.scheme == \"file\"\n\t          && this._sources.has(fileUriAbsPath)) {\n\t        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]\n\t      }\n\t\n\t      if ((!url.path || url.path == \"/\")\n\t          && this._sources.has(\"/\" + aSource)) {\n\t        return this.sourcesContent[this._sources.indexOf(\"/\" + aSource)];\n\t      }\n\t    }\n\t\n\t    // This function is used recursively from\n\t    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we\n\t    // don't want to throw if we can't find the source - we just want to\n\t    // return null, so we provide a flag to exit gracefully.\n\t    if (nullOnMissing) {\n\t      return null;\n\t    }\n\t    else {\n\t      throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n\t    }\n\t  };\n\t\n\t/**\n\t * Returns the generated line and column information for the original source,\n\t * line, and column positions provided. The only argument is an object with\n\t * the following properties:\n\t *\n\t *   - source: The filename of the original source.\n\t *   - line: The line number in the original source.\n\t *   - column: The column number in the original source.\n\t *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n\t *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n\t *     closest element that is smaller than or greater than the one we are\n\t *     searching for, respectively, if the exact element cannot be found.\n\t *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n\t *\n\t * and an object is returned with the following properties:\n\t *\n\t *   - line: The line number in the generated source, or null.\n\t *   - column: The column number in the generated source, or null.\n\t */\n\tBasicSourceMapConsumer.prototype.generatedPositionFor =\n\t  function SourceMapConsumer_generatedPositionFor(aArgs) {\n\t    var source = util.getArg(aArgs, 'source');\n\t    if (this.sourceRoot != null) {\n\t      source = util.relative(this.sourceRoot, source);\n\t    }\n\t    if (!this._sources.has(source)) {\n\t      return {\n\t        line: null,\n\t        column: null,\n\t        lastColumn: null\n\t      };\n\t    }\n\t    source = this._sources.indexOf(source);\n\t\n\t    var needle = {\n\t      source: source,\n\t      originalLine: util.getArg(aArgs, 'line'),\n\t      originalColumn: util.getArg(aArgs, 'column')\n\t    };\n\t\n\t    var index = this._findMapping(\n\t      needle,\n\t      this._originalMappings,\n\t      \"originalLine\",\n\t      \"originalColumn\",\n\t      util.compareByOriginalPositions,\n\t      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\n\t    );\n\t\n\t    if (index >= 0) {\n\t      var mapping = this._originalMappings[index];\n\t\n\t      if (mapping.source === needle.source) {\n\t        return {\n\t          line: util.getArg(mapping, 'generatedLine', null),\n\t          column: util.getArg(mapping, 'generatedColumn', null),\n\t          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n\t        };\n\t      }\n\t    }\n\t\n\t    return {\n\t      line: null,\n\t      column: null,\n\t      lastColumn: null\n\t    };\n\t  };\n\t\n\texports.BasicSourceMapConsumer = BasicSourceMapConsumer;\n\t\n\t/**\n\t * An IndexedSourceMapConsumer instance represents a parsed source map which\n\t * we can query for information. It differs from BasicSourceMapConsumer in\n\t * that it takes \"indexed\" source maps (i.e. ones with a \"sections\" field) as\n\t * input.\n\t *\n\t * The only parameter is a raw source map (either as a JSON string, or already\n\t * parsed to an object). According to the spec for indexed source maps, they\n\t * have the following attributes:\n\t *\n\t *   - version: Which version of the source map spec this map is following.\n\t *   - file: Optional. The generated file this source map is associated with.\n\t *   - sections: A list of section definitions.\n\t *\n\t * Each value under the \"sections\" field has two fields:\n\t *   - offset: The offset into the original specified at which this section\n\t *       begins to apply, defined as an object with a \"line\" and \"column\"\n\t *       field.\n\t *   - map: A source map definition. This source map could also be indexed,\n\t *       but doesn't have to be.\n\t *\n\t * Instead of the \"map\" field, it's also possible to have a \"url\" field\n\t * specifying a URL to retrieve a source map from, but that's currently\n\t * unsupported.\n\t *\n\t * Here's an example source map, taken from the source map spec[0], but\n\t * modified to omit a section which uses the \"url\" field.\n\t *\n\t *  {\n\t *    version : 3,\n\t *    file: \"app.js\",\n\t *    sections: [{\n\t *      offset: {line:100, column:10},\n\t *      map: {\n\t *        version : 3,\n\t *        file: \"section.js\",\n\t *        sources: [\"foo.js\", \"bar.js\"],\n\t *        names: [\"src\", \"maps\", \"are\", \"fun\"],\n\t *        mappings: \"AAAA,E;;ABCDE;\"\n\t *      }\n\t *    }],\n\t *  }\n\t *\n\t * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt\n\t */\n\tfunction IndexedSourceMapConsumer(aSourceMap) {\n\t  var sourceMap = aSourceMap;\n\t  if (typeof aSourceMap === 'string') {\n\t    sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n\t  }\n\t\n\t  var version = util.getArg(sourceMap, 'version');\n\t  var sections = util.getArg(sourceMap, 'sections');\n\t\n\t  if (version != this._version) {\n\t    throw new Error('Unsupported version: ' + version);\n\t  }\n\t\n\t  this._sources = new ArraySet();\n\t  this._names = new ArraySet();\n\t\n\t  var lastOffset = {\n\t    line: -1,\n\t    column: 0\n\t  };\n\t  this._sections = sections.map(function (s) {\n\t    if (s.url) {\n\t      // The url field will require support for asynchronicity.\n\t      // See https://github.com/mozilla/source-map/issues/16\n\t      throw new Error('Support for url field in sections not implemented.');\n\t    }\n\t    var offset = util.getArg(s, 'offset');\n\t    var offsetLine = util.getArg(offset, 'line');\n\t    var offsetColumn = util.getArg(offset, 'column');\n\t\n\t    if (offsetLine < lastOffset.line ||\n\t        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {\n\t      throw new Error('Section offsets must be ordered and non-overlapping.');\n\t    }\n\t    lastOffset = offset;\n\t\n\t    return {\n\t      generatedOffset: {\n\t        // The offset fields are 0-based, but we use 1-based indices when\n\t        // encoding/decoding from VLQ.\n\t        generatedLine: offsetLine + 1,\n\t        generatedColumn: offsetColumn + 1\n\t      },\n\t      consumer: new SourceMapConsumer(util.getArg(s, 'map'))\n\t    }\n\t  });\n\t}\n\t\n\tIndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\n\tIndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;\n\t\n\t/**\n\t * The version of the source mapping spec that we are consuming.\n\t */\n\tIndexedSourceMapConsumer.prototype._version = 3;\n\t\n\t/**\n\t * The list of original sources.\n\t */\n\tObject.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {\n\t  get: function () {\n\t    var sources = [];\n\t    for (var i = 0; i < this._sections.length; i++) {\n\t      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {\n\t        sources.push(this._sections[i].consumer.sources[j]);\n\t      }\n\t    }\n\t    return sources;\n\t  }\n\t});\n\t\n\t/**\n\t * Returns the original source, line, and column information for the generated\n\t * source's line and column positions provided. The only argument is an object\n\t * with the following properties:\n\t *\n\t *   - line: The line number in the generated source.\n\t *   - column: The column number in the generated source.\n\t *\n\t * and an object is returned with the following properties:\n\t *\n\t *   - source: The original source file, or null.\n\t *   - line: The line number in the original source, or null.\n\t *   - column: The column number in the original source, or null.\n\t *   - name: The original identifier, or null.\n\t */\n\tIndexedSourceMapConsumer.prototype.originalPositionFor =\n\t  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {\n\t    var needle = {\n\t      generatedLine: util.getArg(aArgs, 'line'),\n\t      generatedColumn: util.getArg(aArgs, 'column')\n\t    };\n\t\n\t    // Find the section containing the generated position we're trying to map\n\t    // to an original position.\n\t    var sectionIndex = binarySearch.search(needle, this._sections,\n\t      function(needle, section) {\n\t        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;\n\t        if (cmp) {\n\t          return cmp;\n\t        }\n\t\n\t        return (needle.generatedColumn -\n\t                section.generatedOffset.generatedColumn);\n\t      });\n\t    var section = this._sections[sectionIndex];\n\t\n\t    if (!section) {\n\t      return {\n\t        source: null,\n\t        line: null,\n\t        column: null,\n\t        name: null\n\t      };\n\t    }\n\t\n\t    return section.consumer.originalPositionFor({\n\t      line: needle.generatedLine -\n\t        (section.generatedOffset.generatedLine - 1),\n\t      column: needle.generatedColumn -\n\t        (section.generatedOffset.generatedLine === needle.generatedLine\n\t         ? section.generatedOffset.generatedColumn - 1\n\t         : 0),\n\t      bias: aArgs.bias\n\t    });\n\t  };\n\t\n\t/**\n\t * Return true if we have the source content for every source in the source\n\t * map, false otherwise.\n\t */\n\tIndexedSourceMapConsumer.prototype.hasContentsOfAllSources =\n\t  function IndexedSourceMapConsumer_hasContentsOfAllSources() {\n\t    return this._sections.every(function (s) {\n\t      return s.consumer.hasContentsOfAllSources();\n\t    });\n\t  };\n\t\n\t/**\n\t * Returns the original source content. The only argument is the url of the\n\t * original source file. Returns null if no original source content is\n\t * available.\n\t */\n\tIndexedSourceMapConsumer.prototype.sourceContentFor =\n\t  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n\t    for (var i = 0; i < this._sections.length; i++) {\n\t      var section = this._sections[i];\n\t\n\t      var content = section.consumer.sourceContentFor(aSource, true);\n\t      if (content) {\n\t        return content;\n\t      }\n\t    }\n\t    if (nullOnMissing) {\n\t      return null;\n\t    }\n\t    else {\n\t      throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n\t    }\n\t  };\n\t\n\t/**\n\t * Returns the generated line and column information for the original source,\n\t * line, and column positions provided. The only argument is an object with\n\t * the following properties:\n\t *\n\t *   - source: The filename of the original source.\n\t *   - line: The line number in the original source.\n\t *   - column: The column number in the original source.\n\t *\n\t * and an object is returned with the following properties:\n\t *\n\t *   - line: The line number in the generated source, or null.\n\t *   - column: The column number in the generated source, or null.\n\t */\n\tIndexedSourceMapConsumer.prototype.generatedPositionFor =\n\t  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {\n\t    for (var i = 0; i < this._sections.length; i++) {\n\t      var section = this._sections[i];\n\t\n\t      // Only consider this section if the requested source is in the list of\n\t      // sources of the consumer.\n\t      if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {\n\t        continue;\n\t      }\n\t      var generatedPosition = section.consumer.generatedPositionFor(aArgs);\n\t      if (generatedPosition) {\n\t        var ret = {\n\t          line: generatedPosition.line +\n\t            (section.generatedOffset.generatedLine - 1),\n\t          column: generatedPosition.column +\n\t            (section.generatedOffset.generatedLine === generatedPosition.line\n\t             ? section.generatedOffset.generatedColumn - 1\n\t             : 0)\n\t        };\n\t        return ret;\n\t      }\n\t    }\n\t\n\t    return {\n\t      line: null,\n\t      column: null\n\t    };\n\t  };\n\t\n\t/**\n\t * Parse the mappings in a string in to a data structure which we can easily\n\t * query (the ordered arrays in the `this.__generatedMappings` and\n\t * `this.__originalMappings` properties).\n\t */\n\tIndexedSourceMapConsumer.prototype._parseMappings =\n\t  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n\t    this.__generatedMappings = [];\n\t    this.__originalMappings = [];\n\t    for (var i = 0; i < this._sections.length; i++) {\n\t      var section = this._sections[i];\n\t      var sectionMappings = section.consumer._generatedMappings;\n\t      for (var j = 0; j < sectionMappings.length; j++) {\n\t        var mapping = sectionMappings[j];\n\t\n\t        var source = section.consumer._sources.at(mapping.source);\n\t        if (section.consumer.sourceRoot !== null) {\n\t          source = util.join(section.consumer.sourceRoot, source);\n\t        }\n\t        this._sources.add(source);\n\t        source = this._sources.indexOf(source);\n\t\n\t        var name = section.consumer._names.at(mapping.name);\n\t        this._names.add(name);\n\t        name = this._names.indexOf(name);\n\t\n\t        // The mappings coming from the consumer for the section have\n\t        // generated positions relative to the start of the section, so we\n\t        // need to offset them to be relative to the start of the concatenated\n\t        // generated file.\n\t        var adjustedMapping = {\n\t          source: source,\n\t          generatedLine: mapping.generatedLine +\n\t            (section.generatedOffset.generatedLine - 1),\n\t          generatedColumn: mapping.generatedColumn +\n\t            (section.generatedOffset.generatedLine === mapping.generatedLine\n\t            ? section.generatedOffset.generatedColumn - 1\n\t            : 0),\n\t          originalLine: mapping.originalLine,\n\t          originalColumn: mapping.originalColumn,\n\t          name: name\n\t        };\n\t\n\t        this.__generatedMappings.push(adjustedMapping);\n\t        if (typeof adjustedMapping.originalLine === 'number') {\n\t          this.__originalMappings.push(adjustedMapping);\n\t        }\n\t      }\n\t    }\n\t\n\t    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);\n\t    quickSort(this.__originalMappings, util.compareByOriginalPositions);\n\t  };\n\t\n\texports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports) {\n\n\t/* -*- Mode: js; js-indent-level: 2; -*- */\n\t/*\n\t * Copyright 2011 Mozilla Foundation and contributors\n\t * Licensed under the New BSD license. See LICENSE or:\n\t * http://opensource.org/licenses/BSD-3-Clause\n\t */\n\t\n\texports.GREATEST_LOWER_BOUND = 1;\n\texports.LEAST_UPPER_BOUND = 2;\n\t\n\t/**\n\t * Recursive implementation of binary search.\n\t *\n\t * @param aLow Indices here and lower do not contain the needle.\n\t * @param aHigh Indices here and higher do not contain the needle.\n\t * @param aNeedle The element being searched for.\n\t * @param aHaystack The non-empty array being searched.\n\t * @param aCompare Function which takes two elements and returns -1, 0, or 1.\n\t * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n\t *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n\t *     closest element that is smaller than or greater than the one we are\n\t *     searching for, respectively, if the exact element cannot be found.\n\t */\n\tfunction recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {\n\t  // This function terminates when one of the following is true:\n\t  //\n\t  //   1. We find the exact element we are looking for.\n\t  //\n\t  //   2. We did not find the exact element, but we can return the index of\n\t  //      the next-closest element.\n\t  //\n\t  //   3. We did not find the exact element, and there is no next-closest\n\t  //      element than the one we are searching for, so we return -1.\n\t  var mid = Math.floor((aHigh - aLow) / 2) + aLow;\n\t  var cmp = aCompare(aNeedle, aHaystack[mid], true);\n\t  if (cmp === 0) {\n\t    // Found the element we are looking for.\n\t    return mid;\n\t  }\n\t  else if (cmp > 0) {\n\t    // Our needle is greater than aHaystack[mid].\n\t    if (aHigh - mid > 1) {\n\t      // The element is in the upper half.\n\t      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);\n\t    }\n\t\n\t    // The exact needle element was not found in this haystack. Determine if\n\t    // we are in termination case (3) or (2) and return the appropriate thing.\n\t    if (aBias == exports.LEAST_UPPER_BOUND) {\n\t      return aHigh < aHaystack.length ? aHigh : -1;\n\t    } else {\n\t      return mid;\n\t    }\n\t  }\n\t  else {\n\t    // Our needle is less than aHaystack[mid].\n\t    if (mid - aLow > 1) {\n\t      // The element is in the lower half.\n\t      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);\n\t    }\n\t\n\t    // we are in termination case (3) or (2) and return the appropriate thing.\n\t    if (aBias == exports.LEAST_UPPER_BOUND) {\n\t      return mid;\n\t    } else {\n\t      return aLow < 0 ? -1 : aLow;\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * This is an implementation of binary search which will always try and return\n\t * the index of the closest element if there is no exact hit. This is because\n\t * mappings between original and generated line/col pairs are single points,\n\t * and there is an implicit region between each of them, so a miss just means\n\t * that you aren't on the very start of a region.\n\t *\n\t * @param aNeedle The element you are looking for.\n\t * @param aHaystack The array that is being searched.\n\t * @param aCompare A function which takes the needle and an element in the\n\t *     array and returns -1, 0, or 1 depending on whether the needle is less\n\t *     than, equal to, or greater than the element, respectively.\n\t * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n\t *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n\t *     closest element that is smaller than or greater than the one we are\n\t *     searching for, respectively, if the exact element cannot be found.\n\t *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.\n\t */\n\texports.search = function search(aNeedle, aHaystack, aCompare, aBias) {\n\t  if (aHaystack.length === 0) {\n\t    return -1;\n\t  }\n\t\n\t  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,\n\t                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);\n\t  if (index < 0) {\n\t    return -1;\n\t  }\n\t\n\t  // We have found either the exact element, or the next-closest element than\n\t  // the one we are searching for. However, there may be more than one such\n\t  // element. Make sure we always return the smallest of these.\n\t  while (index - 1 >= 0) {\n\t    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {\n\t      break;\n\t    }\n\t    --index;\n\t  }\n\t\n\t  return index;\n\t};\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports) {\n\n\t/* -*- Mode: js; js-indent-level: 2; -*- */\n\t/*\n\t * Copyright 2011 Mozilla Foundation and contributors\n\t * Licensed under the New BSD license. See LICENSE or:\n\t * http://opensource.org/licenses/BSD-3-Clause\n\t */\n\t\n\t// It turns out that some (most?) JavaScript engines don't self-host\n\t// `Array.prototype.sort`. This makes sense because C++ will likely remain\n\t// faster than JS when doing raw CPU-intensive sorting. However, when using a\n\t// custom comparator function, calling back and forth between the VM's C++ and\n\t// JIT'd JS is rather slow *and* loses JIT type information, resulting in\n\t// worse generated code for the comparator function than would be optimal. In\n\t// fact, when sorting with a comparator, these costs outweigh the benefits of\n\t// sorting in C++. By using our own JS-implemented Quick Sort (below), we get\n\t// a ~3500ms mean speed-up in `bench/bench.html`.\n\t\n\t/**\n\t * Swap the elements indexed by `x` and `y` in the array `ary`.\n\t *\n\t * @param {Array} ary\n\t *        The array.\n\t * @param {Number} x\n\t *        The index of the first item.\n\t * @param {Number} y\n\t *        The index of the second item.\n\t */\n\tfunction swap(ary, x, y) {\n\t  var temp = ary[x];\n\t  ary[x] = ary[y];\n\t  ary[y] = temp;\n\t}\n\t\n\t/**\n\t * Returns a random integer within the range `low .. high` inclusive.\n\t *\n\t * @param {Number} low\n\t *        The lower bound on the range.\n\t * @param {Number} high\n\t *        The upper bound on the range.\n\t */\n\tfunction randomIntInRange(low, high) {\n\t  return Math.round(low + (Math.random() * (high - low)));\n\t}\n\t\n\t/**\n\t * The Quick Sort algorithm.\n\t *\n\t * @param {Array} ary\n\t *        An array to sort.\n\t * @param {function} comparator\n\t *        Function to use to compare two items.\n\t * @param {Number} p\n\t *        Start index of the array\n\t * @param {Number} r\n\t *        End index of the array\n\t */\n\tfunction doQuickSort(ary, comparator, p, r) {\n\t  // If our lower bound is less than our upper bound, we (1) partition the\n\t  // array into two pieces and (2) recurse on each half. If it is not, this is\n\t  // the empty array and our base case.\n\t\n\t  if (p < r) {\n\t    // (1) Partitioning.\n\t    //\n\t    // The partitioning chooses a pivot between `p` and `r` and moves all\n\t    // elements that are less than or equal to the pivot to the before it, and\n\t    // all the elements that are greater than it after it. The effect is that\n\t    // once partition is done, the pivot is in the exact place it will be when\n\t    // the array is put in sorted order, and it will not need to be moved\n\t    // again. This runs in O(n) time.\n\t\n\t    // Always choose a random pivot so that an input array which is reverse\n\t    // sorted does not cause O(n^2) running time.\n\t    var pivotIndex = randomIntInRange(p, r);\n\t    var i = p - 1;\n\t\n\t    swap(ary, pivotIndex, r);\n\t    var pivot = ary[r];\n\t\n\t    // Immediately after `j` is incremented in this loop, the following hold\n\t    // true:\n\t    //\n\t    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.\n\t    //\n\t    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.\n\t    for (var j = p; j < r; j++) {\n\t      if (comparator(ary[j], pivot) <= 0) {\n\t        i += 1;\n\t        swap(ary, i, j);\n\t      }\n\t    }\n\t\n\t    swap(ary, i + 1, j);\n\t    var q = i + 1;\n\t\n\t    // (2) Recurse on each half.\n\t\n\t    doQuickSort(ary, comparator, p, q - 1);\n\t    doQuickSort(ary, comparator, q + 1, r);\n\t  }\n\t}\n\t\n\t/**\n\t * Sort the given array in-place with the given comparator function.\n\t *\n\t * @param {Array} ary\n\t *        An array to sort.\n\t * @param {function} comparator\n\t *        Function to use to compare two items.\n\t */\n\texports.quickSort = function (ary, comparator) {\n\t  doQuickSort(ary, comparator, 0, ary.length - 1);\n\t};\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* -*- Mode: js; js-indent-level: 2; -*- */\n\t/*\n\t * Copyright 2011 Mozilla Foundation and contributors\n\t * Licensed under the New BSD license. See LICENSE or:\n\t * http://opensource.org/licenses/BSD-3-Clause\n\t */\n\t\n\tvar SourceMapGenerator = __webpack_require__(4).SourceMapGenerator;\n\tvar util = __webpack_require__(7);\n\t\n\t// Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\n\t// operating systems these days (capturing the result).\n\tvar REGEX_NEWLINE = /(\\r?\\n)/;\n\t\n\t// Newline character code for charCodeAt() comparisons\n\tvar NEWLINE_CODE = 10;\n\t\n\t// Private symbol for identifying `SourceNode`s when multiple versions of\n\t// the source-map library are loaded. This MUST NOT CHANGE across\n\t// versions!\n\tvar isSourceNode = \"$$$isSourceNode$$$\";\n\t\n\t/**\n\t * SourceNodes provide a way to abstract over interpolating/concatenating\n\t * snippets of generated JavaScript source code while maintaining the line and\n\t * column information associated with the original source code.\n\t *\n\t * @param aLine The original line number.\n\t * @param aColumn The original column number.\n\t * @param aSource The original source's filename.\n\t * @param aChunks Optional. An array of strings which are snippets of\n\t *        generated JS, or other SourceNodes.\n\t * @param aName The original identifier.\n\t */\n\tfunction SourceNode(aLine, aColumn, aSource, aChunks, aName) {\n\t  this.children = [];\n\t  this.sourceContents = {};\n\t  this.line = aLine == null ? null : aLine;\n\t  this.column = aColumn == null ? null : aColumn;\n\t  this.source = aSource == null ? null : aSource;\n\t  this.name = aName == null ? null : aName;\n\t  this[isSourceNode] = true;\n\t  if (aChunks != null) this.add(aChunks);\n\t}\n\t\n\t/**\n\t * Creates a SourceNode from generated code and a SourceMapConsumer.\n\t *\n\t * @param aGeneratedCode The generated code\n\t * @param aSourceMapConsumer The SourceMap for the generated code\n\t * @param aRelativePath Optional. The path that relative sources in the\n\t *        SourceMapConsumer should be relative to.\n\t */\n\tSourceNode.fromStringWithSourceMap =\n\t  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\n\t    // The SourceNode we want to fill with the generated code\n\t    // and the SourceMap\n\t    var node = new SourceNode();\n\t\n\t    // All even indices of this array are one line of the generated code,\n\t    // while all odd indices are the newlines between two adjacent lines\n\t    // (since `REGEX_NEWLINE` captures its match).\n\t    // Processed fragments are removed from this array, by calling `shiftNextLine`.\n\t    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\n\t    var shiftNextLine = function() {\n\t      var lineContents = remainingLines.shift();\n\t      // The last line of a file might not have a newline.\n\t      var newLine = remainingLines.shift() || \"\";\n\t      return lineContents + newLine;\n\t    };\n\t\n\t    // We need to remember the position of \"remainingLines\"\n\t    var lastGeneratedLine = 1, lastGeneratedColumn = 0;\n\t\n\t    // The generate SourceNodes we need a code range.\n\t    // To extract it current and last mapping is used.\n\t    // Here we store the last mapping.\n\t    var lastMapping = null;\n\t\n\t    aSourceMapConsumer.eachMapping(function (mapping) {\n\t      if (lastMapping !== null) {\n\t        // We add the code from \"lastMapping\" to \"mapping\":\n\t        // First check if there is a new line in between.\n\t        if (lastGeneratedLine < mapping.generatedLine) {\n\t          // Associate first line with \"lastMapping\"\n\t          addMappingWithCode(lastMapping, shiftNextLine());\n\t          lastGeneratedLine++;\n\t          lastGeneratedColumn = 0;\n\t          // The remaining code is added without mapping\n\t        } else {\n\t          // There is no new line in between.\n\t          // Associate the code between \"lastGeneratedColumn\" and\n\t          // \"mapping.generatedColumn\" with \"lastMapping\"\n\t          var nextLine = remainingLines[0];\n\t          var code = nextLine.substr(0, mapping.generatedColumn -\n\t                                        lastGeneratedColumn);\n\t          remainingLines[0] = nextLine.substr(mapping.generatedColumn -\n\t                                              lastGeneratedColumn);\n\t          lastGeneratedColumn = mapping.generatedColumn;\n\t          addMappingWithCode(lastMapping, code);\n\t          // No more remaining code, continue\n\t          lastMapping = mapping;\n\t          return;\n\t        }\n\t      }\n\t      // We add the generated code until the first mapping\n\t      // to the SourceNode without any mapping.\n\t      // Each line is added as separate string.\n\t      while (lastGeneratedLine < mapping.generatedLine) {\n\t        node.add(shiftNextLine());\n\t        lastGeneratedLine++;\n\t      }\n\t      if (lastGeneratedColumn < mapping.generatedColumn) {\n\t        var nextLine = remainingLines[0];\n\t        node.add(nextLine.substr(0, mapping.generatedColumn));\n\t        remainingLines[0] = nextLine.substr(mapping.generatedColumn);\n\t        lastGeneratedColumn = mapping.generatedColumn;\n\t      }\n\t      lastMapping = mapping;\n\t    }, this);\n\t    // We have processed all mappings.\n\t    if (remainingLines.length > 0) {\n\t      if (lastMapping) {\n\t        // Associate the remaining code in the current line with \"lastMapping\"\n\t        addMappingWithCode(lastMapping, shiftNextLine());\n\t      }\n\t      // and add the remaining lines without any mapping\n\t      node.add(remainingLines.join(\"\"));\n\t    }\n\t\n\t    // Copy sourcesContent into SourceNode\n\t    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n\t      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n\t      if (content != null) {\n\t        if (aRelativePath != null) {\n\t          sourceFile = util.join(aRelativePath, sourceFile);\n\t        }\n\t        node.setSourceContent(sourceFile, content);\n\t      }\n\t    });\n\t\n\t    return node;\n\t\n\t    function addMappingWithCode(mapping, code) {\n\t      if (mapping === null || mapping.source === undefined) {\n\t        node.add(code);\n\t      } else {\n\t        var source = aRelativePath\n\t          ? util.join(aRelativePath, mapping.source)\n\t          : mapping.source;\n\t        node.add(new SourceNode(mapping.originalLine,\n\t                                mapping.originalColumn,\n\t                                source,\n\t                                code,\n\t                                mapping.name));\n\t      }\n\t    }\n\t  };\n\t\n\t/**\n\t * Add a chunk of generated JS to this source node.\n\t *\n\t * @param aChunk A string snippet of generated JS code, another instance of\n\t *        SourceNode, or an array where each member is one of those things.\n\t */\n\tSourceNode.prototype.add = function SourceNode_add(aChunk) {\n\t  if (Array.isArray(aChunk)) {\n\t    aChunk.forEach(function (chunk) {\n\t      this.add(chunk);\n\t    }, this);\n\t  }\n\t  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n\t    if (aChunk) {\n\t      this.children.push(aChunk);\n\t    }\n\t  }\n\t  else {\n\t    throw new TypeError(\n\t      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n\t    );\n\t  }\n\t  return this;\n\t};\n\t\n\t/**\n\t * Add a chunk of generated JS to the beginning of this source node.\n\t *\n\t * @param aChunk A string snippet of generated JS code, another instance of\n\t *        SourceNode, or an array where each member is one of those things.\n\t */\n\tSourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {\n\t  if (Array.isArray(aChunk)) {\n\t    for (var i = aChunk.length-1; i >= 0; i--) {\n\t      this.prepend(aChunk[i]);\n\t    }\n\t  }\n\t  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n\t    this.children.unshift(aChunk);\n\t  }\n\t  else {\n\t    throw new TypeError(\n\t      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n\t    );\n\t  }\n\t  return this;\n\t};\n\t\n\t/**\n\t * Walk over the tree of JS snippets in this node and its children. The\n\t * walking function is called once for each snippet of JS and is passed that\n\t * snippet and the its original associated source's line/column location.\n\t *\n\t * @param aFn The traversal function.\n\t */\n\tSourceNode.prototype.walk = function SourceNode_walk(aFn) {\n\t  var chunk;\n\t  for (var i = 0, len = this.children.length; i < len; i++) {\n\t    chunk = this.children[i];\n\t    if (chunk[isSourceNode]) {\n\t      chunk.walk(aFn);\n\t    }\n\t    else {\n\t      if (chunk !== '') {\n\t        aFn(chunk, { source: this.source,\n\t                     line: this.line,\n\t                     column: this.column,\n\t                     name: this.name });\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\n\t * each of `this.children`.\n\t *\n\t * @param aSep The separator.\n\t */\n\tSourceNode.prototype.join = function SourceNode_join(aSep) {\n\t  var newChildren;\n\t  var i;\n\t  var len = this.children.length;\n\t  if (len > 0) {\n\t    newChildren = [];\n\t    for (i = 0; i < len-1; i++) {\n\t      newChildren.push(this.children[i]);\n\t      newChildren.push(aSep);\n\t    }\n\t    newChildren.push(this.children[i]);\n\t    this.children = newChildren;\n\t  }\n\t  return this;\n\t};\n\t\n\t/**\n\t * Call String.prototype.replace on the very right-most source snippet. Useful\n\t * for trimming whitespace from the end of a source node, etc.\n\t *\n\t * @param aPattern The pattern to replace.\n\t * @param aReplacement The thing to replace the pattern with.\n\t */\n\tSourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {\n\t  var lastChild = this.children[this.children.length - 1];\n\t  if (lastChild[isSourceNode]) {\n\t    lastChild.replaceRight(aPattern, aReplacement);\n\t  }\n\t  else if (typeof lastChild === 'string') {\n\t    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\n\t  }\n\t  else {\n\t    this.children.push(''.replace(aPattern, aReplacement));\n\t  }\n\t  return this;\n\t};\n\t\n\t/**\n\t * Set the source content for a source file. This will be added to the SourceMapGenerator\n\t * in the sourcesContent field.\n\t *\n\t * @param aSourceFile The filename of the source file\n\t * @param aSourceContent The content of the source file\n\t */\n\tSourceNode.prototype.setSourceContent =\n\t  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {\n\t    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\n\t  };\n\t\n\t/**\n\t * Walk over the tree of SourceNodes. The walking function is called for each\n\t * source file content and is passed the filename and source content.\n\t *\n\t * @param aFn The traversal function.\n\t */\n\tSourceNode.prototype.walkSourceContents =\n\t  function SourceNode_walkSourceContents(aFn) {\n\t    for (var i = 0, len = this.children.length; i < len; i++) {\n\t      if (this.children[i][isSourceNode]) {\n\t        this.children[i].walkSourceContents(aFn);\n\t      }\n\t    }\n\t\n\t    var sources = Object.keys(this.sourceContents);\n\t    for (var i = 0, len = sources.length; i < len; i++) {\n\t      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\n\t    }\n\t  };\n\t\n\t/**\n\t * Return the string representation of this source node. Walks over the tree\n\t * and concatenates all the various snippets together to one string.\n\t */\n\tSourceNode.prototype.toString = function SourceNode_toString() {\n\t  var str = \"\";\n\t  this.walk(function (chunk) {\n\t    str += chunk;\n\t  });\n\t  return str;\n\t};\n\t\n\t/**\n\t * Returns the string representation of this source node along with a source\n\t * map.\n\t */\n\tSourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {\n\t  var generated = {\n\t    code: \"\",\n\t    line: 1,\n\t    column: 0\n\t  };\n\t  var map = new SourceMapGenerator(aArgs);\n\t  var sourceMappingActive = false;\n\t  var lastOriginalSource = null;\n\t  var lastOriginalLine = null;\n\t  var lastOriginalColumn = null;\n\t  var lastOriginalName = null;\n\t  this.walk(function (chunk, original) {\n\t    generated.code += chunk;\n\t    if (original.source !== null\n\t        && original.line !== null\n\t        && original.column !== null) {\n\t      if(lastOriginalSource !== original.source\n\t         || lastOriginalLine !== original.line\n\t         || lastOriginalColumn !== original.column\n\t         || lastOriginalName !== original.name) {\n\t        map.addMapping({\n\t          source: original.source,\n\t          original: {\n\t            line: original.line,\n\t            column: original.column\n\t          },\n\t          generated: {\n\t            line: generated.line,\n\t            column: generated.column\n\t          },\n\t          name: original.name\n\t        });\n\t      }\n\t      lastOriginalSource = original.source;\n\t      lastOriginalLine = original.line;\n\t      lastOriginalColumn = original.column;\n\t      lastOriginalName = original.name;\n\t      sourceMappingActive = true;\n\t    } else if (sourceMappingActive) {\n\t      map.addMapping({\n\t        generated: {\n\t          line: generated.line,\n\t          column: generated.column\n\t        }\n\t      });\n\t      lastOriginalSource = null;\n\t      sourceMappingActive = false;\n\t    }\n\t    for (var idx = 0, length = chunk.length; idx < length; idx++) {\n\t      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\n\t        generated.line++;\n\t        generated.column = 0;\n\t        // Mappings end at eol\n\t        if (idx + 1 === length) {\n\t          lastOriginalSource = null;\n\t          sourceMappingActive = false;\n\t        } else if (sourceMappingActive) {\n\t          map.addMapping({\n\t            source: original.source,\n\t            original: {\n\t              line: original.line,\n\t              column: original.column\n\t            },\n\t            generated: {\n\t              line: generated.line,\n\t              column: generated.column\n\t            },\n\t            name: original.name\n\t          });\n\t        }\n\t      } else {\n\t        generated.column++;\n\t      }\n\t    }\n\t  });\n\t  this.walkSourceContents(function (sourceFile, sourceContent) {\n\t    map.setSourceContent(sourceFile, sourceContent);\n\t  });\n\t\n\t  return { code: generated.code, map: map };\n\t};\n\t\n\texports.SourceNode = SourceNode;\n\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports) {\n\n\tmodule.exports = require(\"path\");\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports) {\n\n\tmodule.exports = require(\"fs\");\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports) {\n\n\tmodule.exports = require(\"module\");\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports) {\n\n\tmodule.exports = require(\"electron\");\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _electron = __webpack_require__(17);\n\t\n\tvar _path = __webpack_require__(14);\n\t\n\tvar _path2 = _interopRequireDefault(_path);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction createLoginWindow(loginCallback) {\n\t    var loginWindow = new _electron.BrowserWindow({\n\t        width: 300,\n\t        height: 400,\n\t        frame: false,\n\t        resizable: false\n\t    });\n\t    loginWindow.loadURL('file://' + _path2.default.join(__dirname, '/static/login/login.html'));\n\t\n\t    _electron.ipcMain.once('login-message', function (event, usernameAndPassword) {\n\t        loginCallback(usernameAndPassword[0], usernameAndPassword[1]);\n\t        loginWindow.close();\n\t    });\n\t    return loginWindow;\n\t}\n\t\n\texports.default = createLoginWindow;\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _fs = __webpack_require__(15);\n\t\n\tvar _fs2 = _interopRequireDefault(_fs);\n\t\n\tvar _path = __webpack_require__(14);\n\t\n\tvar _path2 = _interopRequireDefault(_path);\n\t\n\tvar _electron = __webpack_require__(17);\n\t\n\tvar _electronWindowState = __webpack_require__(20);\n\t\n\tvar _electronWindowState2 = _interopRequireDefault(_electronWindowState);\n\t\n\tvar _helpers = __webpack_require__(34);\n\t\n\tvar _helpers2 = _interopRequireDefault(_helpers);\n\t\n\tvar _menu = __webpack_require__(37);\n\t\n\tvar _menu2 = _interopRequireDefault(_menu);\n\t\n\tvar _contextMenu = __webpack_require__(38);\n\t\n\tvar _contextMenu2 = _interopRequireDefault(_contextMenu);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar isOSX = _helpers2.default.isOSX,\n\t    linkIsInternal = _helpers2.default.linkIsInternal,\n\t    getCssToInject = _helpers2.default.getCssToInject,\n\t    shouldInjectCss = _helpers2.default.shouldInjectCss;\n\t\n\t\n\tvar ZOOM_INTERVAL = 0.1;\n\t\n\t/**\n\t *\n\t * @param {{}} options AppArgs from nativefier.json\n\t * @param {function} onAppQuit\n\t * @param {function} setDockBadge\n\t * @returns {electron.BrowserWindow}\n\t */\n\tfunction createMainWindow(options, onAppQuit, setDockBadge) {\n\t    var _this = this;\n\t\n\t    var mainWindowState = (0, _electronWindowState2.default)({\n\t        defaultWidth: options.width || 1280,\n\t        defaultHeight: options.height || 800\n\t    });\n\t\n\t    var mainWindow = new _electron.BrowserWindow({\n\t        frame: !options.hideWindowFrame,\n\t        width: mainWindowState.width,\n\t        height: mainWindowState.height,\n\t        minWidth: options.minWidth,\n\t        minHeight: options.minHeight,\n\t        maxWidth: options.maxWidth,\n\t        maxHeight: options.maxHeight,\n\t        x: mainWindowState.x,\n\t        y: mainWindowState.y,\n\t        autoHideMenuBar: !options.showMenuBar,\n\t        // Convert dashes to spaces because on linux the app name is joined with dashes\n\t        title: options.name,\n\t        webPreferences: {\n\t            javascript: true,\n\t            plugins: true,\n\t            // node globals causes problems with sites like messenger.com\n\t            nodeIntegration: false,\n\t            webSecurity: !options.insecure,\n\t            preload: _path2.default.join(__dirname, 'static', 'preload.js'),\n\t            zoomFactor: options.zoom\n\t        },\n\t        // after webpack path here should reference `resources/app/`\n\t        icon: _path2.default.join(__dirname, '../', '/icon.png'),\n\t        // set to undefined and not false because explicitly setting to false will disable full screen\n\t        fullscreen: options.fullScreen || undefined\n\t    });\n\t\n\t    mainWindowState.manage(mainWindow);\n\t\n\t    // after first run, no longer force full screen to be true\n\t    if (options.fullScreen) {\n\t        options.fullScreen = undefined;\n\t        _fs2.default.writeFileSync(_path2.default.join(__dirname, '..', 'nativefier.json'), JSON.stringify(options));\n\t    }\n\t\n\t    // after first run, no longer force maximize to be true\n\t    if (options.maximize) {\n\t        mainWindow.maximize();\n\t        options.maximize = undefined;\n\t        _fs2.default.writeFileSync(_path2.default.join(__dirname, '..', 'nativefier.json'), JSON.stringify(options));\n\t    }\n\t\n\t    var currentZoom = options.zoom;\n\t\n\t    var onZoomIn = function onZoomIn() {\n\t        currentZoom += ZOOM_INTERVAL;\n\t        mainWindow.webContents.send('change-zoom', currentZoom);\n\t    };\n\t\n\t    var onZoomOut = function onZoomOut() {\n\t        currentZoom -= ZOOM_INTERVAL;\n\t        mainWindow.webContents.send('change-zoom', currentZoom);\n\t    };\n\t\n\t    var onZoomReset = function onZoomReset() {\n\t        mainWindow.webContents.send('change-zoom', options.zoom);\n\t    };\n\t\n\t    var clearAppData = function clearAppData() {\n\t        _electron.dialog.showMessageBox(mainWindow, {\n\t            type: 'warning',\n\t            buttons: ['Yes', 'Cancel'],\n\t            defaultId: 1,\n\t            title: 'Clear cache confirmation',\n\t            message: 'This will clear all data (cookies, local storage etc) from this app. Are you sure you wish to proceed?'\n\t        }, function (response) {\n\t            if (response === 0) {\n\t                var session = mainWindow.webContents.session;\n\t                session.clearStorageData(function () {\n\t                    session.clearCache(function () {\n\t                        mainWindow.loadURL(options.targetUrl);\n\t                    });\n\t                });\n\t            }\n\t        });\n\t    };\n\t\n\t    var onGoBack = function onGoBack() {\n\t        mainWindow.webContents.goBack();\n\t    };\n\t\n\t    var onGoForward = function onGoForward() {\n\t        mainWindow.webContents.goForward();\n\t    };\n\t\n\t    var getCurrentUrl = function getCurrentUrl() {\n\t        return mainWindow.webContents.getURL();\n\t    };\n\t\n\t    var menuOptions = {\n\t        nativefierVersion: options.nativefierVersion,\n\t        appQuit: onAppQuit,\n\t        zoomIn: onZoomIn,\n\t        zoomOut: onZoomOut,\n\t        zoomReset: onZoomReset,\n\t        zoomBuildTimeValue: options.zoom,\n\t        goBack: onGoBack,\n\t        goForward: onGoForward,\n\t        getCurrentUrl: getCurrentUrl,\n\t        clearAppData: clearAppData,\n\t        disableDevTools: options.disableDevTools\n\t    };\n\t\n\t    (0, _menu2.default)(menuOptions);\n\t    if (!options.disableContextMenu) {\n\t        (0, _contextMenu2.default)(mainWindow);\n\t    }\n\t\n\t    if (options.userAgent) {\n\t        mainWindow.webContents.setUserAgent(options.userAgent);\n\t    }\n\t\n\t    maybeInjectCss(mainWindow);\n\t    mainWindow.webContents.on('did-finish-load', function () {\n\t        mainWindow.webContents.send('params', JSON.stringify(options));\n\t    });\n\t\n\t    if (options.counter) {\n\t        mainWindow.on('page-title-updated', function (e, title) {\n\t            var itemCountRegex = /[\\(\\[{](\\d*?)[}\\]\\)]/;\n\t            var match = itemCountRegex.exec(title);\n\t            if (match) {\n\t                setDockBadge(match[1]);\n\t            } else {\n\t                setDockBadge('');\n\t            }\n\t        });\n\t    } else {\n\t        _electron.ipcMain.on('notification', function () {\n\t            if (!isOSX() || mainWindow.isFocused()) {\n\t                return;\n\t            }\n\t            setDockBadge('');\n\t        });\n\t        mainWindow.on('focus', function () {\n\t            setDockBadge('');\n\t        });\n\t    }\n\t\n\t    mainWindow.webContents.on('new-window', function (event, urlToGo) {\n\t        if (mainWindow.useDefaultWindowBehaviour) {\n\t            mainWindow.useDefaultWindowBehaviour = false;\n\t            return;\n\t        }\n\t\n\t        if (linkIsInternal(options.targetUrl, urlToGo, options.internalUrls)) {\n\t            return;\n\t        }\n\t        event.preventDefault();\n\t        _electron.shell.openExternal(urlToGo);\n\t    });\n\t\n\t    mainWindow.loadURL(options.targetUrl);\n\t\n\t    mainWindow.on('close', function (event) {\n\t        if (mainWindow.isFullScreen()) {\n\t            mainWindow.setFullScreen(false);\n\t            mainWindow.once('leave-full-screen', maybeHideWindow.bind(_this, mainWindow, event, options.fastQuit));\n\t        }\n\t        maybeHideWindow(mainWindow, event, options.fastQuit);\n\t    });\n\t\n\t    return mainWindow;\n\t}\n\t\n\t_electron.ipcMain.on('cancelNewWindowOverride', function () {\n\t    var allWindows = _electron.BrowserWindow.getAllWindows();\n\t    allWindows.forEach(function (window) {\n\t        window.useDefaultWindowBehaviour = false;\n\t    });\n\t});\n\t\n\tfunction maybeHideWindow(window, event, fastQuit) {\n\t    if (isOSX() && !fastQuit) {\n\t        // this is called when exiting from clicking the cross button on the window\n\t        event.preventDefault();\n\t        window.hide();\n\t    }\n\t    // will close the window on other platforms\n\t}\n\t\n\tfunction maybeInjectCss(browserWindow) {\n\t    if (!shouldInjectCss()) {\n\t        return;\n\t    }\n\t\n\t    var cssToInject = getCssToInject();\n\t\n\t    var injectCss = function injectCss() {\n\t        browserWindow.webContents.insertCSS(cssToInject);\n\t    };\n\t\n\t    browserWindow.webContents.on('did-finish-load', function () {\n\t        // remove the injection of css the moment the page is loaded\n\t        browserWindow.webContents.removeListener('did-get-response-details', injectCss);\n\t    });\n\t\n\t    // on every page navigation inject the css\n\t    browserWindow.webContents.on('did-navigate', function () {\n\t        // we have to inject the css in did-get-response-details to prevent the fouc\n\t        // will run multiple times\n\t        browserWindow.webContents.on('did-get-response-details', injectCss);\n\t    });\n\t}\n\t\n\texports.default = createMainWindow;\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar path = __webpack_require__(14);\n\tvar electron = __webpack_require__(17);\n\tvar jsonfile = __webpack_require__(21);\n\tvar mkdirp = __webpack_require__(30);\n\tvar deepEqual = __webpack_require__(31);\n\t\n\tmodule.exports = function (options) {\n\t  var app = electron.app || electron.remote.app;\n\t  var screen = electron.screen || electron.remote.screen;\n\t  var state;\n\t  var winRef;\n\t  var stateChangeTimer;\n\t  var eventHandlingDelay = 100;\n\t  var config = Object.assign({\n\t    file: 'window-state.json',\n\t    path: app.getPath('userData'),\n\t    maximize: true,\n\t    fullScreen: true\n\t  }, options);\n\t  var fullStoreFileName = path.join(config.path, config.file);\n\t\n\t  function isNormal(win) {\n\t    return !win.isMaximized() && !win.isMinimized() && !win.isFullScreen();\n\t  }\n\t\n\t  function hasBounds() {\n\t    return state &&\n\t      Number.isInteger(state.x) &&\n\t      Number.isInteger(state.y) &&\n\t      Number.isInteger(state.width) && state.width > 0 &&\n\t      Number.isInteger(state.height) && state.height > 0;\n\t  }\n\t\n\t  function validateState() {\n\t    var isValid = state && (hasBounds() || state.isMaximized || state.isFullScreen);\n\t    if (!isValid) {\n\t      state = null;\n\t      return;\n\t    }\n\t\n\t    if (hasBounds() && state.displayBounds) {\n\t      // Check if the display where the window was last open is still available\n\t      var displayBounds = screen.getDisplayMatching(state).bounds;\n\t      var sameBounds = deepEqual(state.displayBounds, displayBounds, {strict: true});\n\t      if (!sameBounds) {\n\t        if (displayBounds.width < state.displayBounds.width) {\n\t          if (state.x > displayBounds.width) {\n\t            state.x = 0;\n\t          }\n\t\n\t          if (state.width > displayBounds.width) {\n\t            state.width = displayBounds.width;\n\t          }\n\t        }\n\t\n\t        if (displayBounds.height < state.displayBounds.height) {\n\t          if (state.y > displayBounds.height) {\n\t            state.y = 0;\n\t          }\n\t\n\t          if (state.height > displayBounds.height) {\n\t            state.height = displayBounds.height;\n\t          }\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  function updateState(win) {\n\t    win = win || winRef;\n\t    if (!win) {\n\t      return;\n\t    }\n\t    // don't throw an error when window was closed\n\t    try {\n\t      var winBounds = win.getBounds();\n\t      if (isNormal(win)) {\n\t        state.x = winBounds.x;\n\t        state.y = winBounds.y;\n\t        state.width = winBounds.width;\n\t        state.height = winBounds.height;\n\t      }\n\t      state.isMaximized = win.isMaximized();\n\t      state.isFullScreen = win.isFullScreen();\n\t      state.displayBounds = screen.getDisplayMatching(winBounds).bounds;\n\t    } catch (err) {}\n\t  }\n\t\n\t  function saveState(win) {\n\t    // Update window state only if it was provided\n\t    if (win) {\n\t      updateState(win);\n\t    }\n\t\n\t    // Save state\n\t    try {\n\t      mkdirp.sync(path.dirname(fullStoreFileName));\n\t      jsonfile.writeFileSync(fullStoreFileName, state);\n\t    } catch (err) {\n\t      // Don't care\n\t    }\n\t  }\n\t\n\t  function stateChangeHandler() {\n\t    // Handles both 'resize' and 'move'\n\t    clearTimeout(stateChangeTimer);\n\t    stateChangeTimer = setTimeout(updateState, eventHandlingDelay);\n\t  }\n\t\n\t  function closeHandler() {\n\t    updateState();\n\t  }\n\t\n\t  function closedHandler() {\n\t    // Unregister listeners and save state\n\t    unmanage();\n\t    saveState();\n\t  }\n\t\n\t  function manage(win) {\n\t    if (config.maximize && state.isMaximized) {\n\t      win.maximize();\n\t    }\n\t    if (config.fullScreen && state.isFullScreen) {\n\t      win.setFullScreen(true);\n\t    }\n\t    win.on('resize', stateChangeHandler);\n\t    win.on('move', stateChangeHandler);\n\t    win.on('close', closeHandler);\n\t    win.on('closed', closedHandler);\n\t    winRef = win;\n\t  }\n\t\n\t  function unmanage() {\n\t    if (winRef) {\n\t      winRef.removeListener('resize', stateChangeHandler);\n\t      winRef.removeListener('move', stateChangeHandler);\n\t      clearTimeout(stateChangeTimer);\n\t      winRef.removeListener('close', closeHandler);\n\t      winRef.removeListener('closed', closedHandler);\n\t      winRef = null;\n\t    }\n\t  }\n\t\n\t  // Load previous state\n\t  try {\n\t    state = jsonfile.readFileSync(fullStoreFileName);\n\t  } catch (err) {\n\t    // Don't care\n\t  }\n\t\n\t  // Check state validity\n\t  validateState();\n\t\n\t  // Set state fallback values\n\t  state = Object.assign({\n\t    width: config.defaultWidth || 800,\n\t    height: config.defaultHeight || 600\n\t  }, state);\n\t\n\t  return {\n\t    get x() { return state.x; },\n\t    get y() { return state.y; },\n\t    get width() { return state.width; },\n\t    get height() { return state.height; },\n\t    get isMaximized() { return state.isMaximized; },\n\t    get isFullScreen() { return state.isFullScreen; },\n\t    saveState: saveState,\n\t    unmanage: unmanage,\n\t    manage: manage\n\t  };\n\t};\n\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar _fs\n\ttry {\n\t  _fs = __webpack_require__(22)\n\t} catch (_) {\n\t  _fs = __webpack_require__(15)\n\t}\n\t\n\tfunction readFile (file, options, callback) {\n\t  if (callback == null) {\n\t    callback = options\n\t    options = {}\n\t  }\n\t\n\t  if (typeof options === 'string') {\n\t    options = {encoding: options}\n\t  }\n\t\n\t  options = options || {}\n\t  var fs = options.fs || _fs\n\t\n\t  var shouldThrow = true\n\t  // DO NOT USE 'passParsingErrors' THE NAME WILL CHANGE!!!, use 'throws' instead\n\t  if ('passParsingErrors' in options) {\n\t    shouldThrow = options.passParsingErrors\n\t  } else if ('throws' in options) {\n\t    shouldThrow = options.throws\n\t  }\n\t\n\t  fs.readFile(file, options, function (err, data) {\n\t    if (err) return callback(err)\n\t\n\t    data = stripBom(data)\n\t\n\t    var obj\n\t    try {\n\t      obj = JSON.parse(data, options ? options.reviver : null)\n\t    } catch (err2) {\n\t      if (shouldThrow) {\n\t        err2.message = file + ': ' + err2.message\n\t        return callback(err2)\n\t      } else {\n\t        return callback(null, null)\n\t      }\n\t    }\n\t\n\t    callback(null, obj)\n\t  })\n\t}\n\t\n\tfunction readFileSync (file, options) {\n\t  options = options || {}\n\t  if (typeof options === 'string') {\n\t    options = {encoding: options}\n\t  }\n\t\n\t  var fs = options.fs || _fs\n\t\n\t  var shouldThrow = true\n\t  // DO NOT USE 'passParsingErrors' THE NAME WILL CHANGE!!!, use 'throws' instead\n\t  if ('passParsingErrors' in options) {\n\t    shouldThrow = options.passParsingErrors\n\t  } else if ('throws' in options) {\n\t    shouldThrow = options.throws\n\t  }\n\t\n\t  var content = fs.readFileSync(file, options)\n\t  content = stripBom(content)\n\t\n\t  try {\n\t    return JSON.parse(content, options.reviver)\n\t  } catch (err) {\n\t    if (shouldThrow) {\n\t      err.message = file + ': ' + err.message\n\t      throw err\n\t    } else {\n\t      return null\n\t    }\n\t  }\n\t}\n\t\n\tfunction writeFile (file, obj, options, callback) {\n\t  if (callback == null) {\n\t    callback = options\n\t    options = {}\n\t  }\n\t  options = options || {}\n\t  var fs = options.fs || _fs\n\t\n\t  var spaces = typeof options === 'object' && options !== null\n\t    ? 'spaces' in options\n\t    ? options.spaces : this.spaces\n\t    : this.spaces\n\t\n\t  var str = ''\n\t  try {\n\t    str = JSON.stringify(obj, options ? options.replacer : null, spaces) + '\\n'\n\t  } catch (err) {\n\t    if (callback) return callback(err, null)\n\t  }\n\t\n\t  fs.writeFile(file, str, options, callback)\n\t}\n\t\n\tfunction writeFileSync (file, obj, options) {\n\t  options = options || {}\n\t  var fs = options.fs || _fs\n\t\n\t  var spaces = typeof options === 'object' && options !== null\n\t    ? 'spaces' in options\n\t    ? options.spaces : this.spaces\n\t    : this.spaces\n\t\n\t  var str = JSON.stringify(obj, options.replacer, spaces) + '\\n'\n\t  // not sure if fs.writeFileSync returns anything, but just in case\n\t  return fs.writeFileSync(file, str, options)\n\t}\n\t\n\tfunction stripBom (content) {\n\t  // we do this because JSON.parse would convert it to a utf8 string if encoding wasn't specified\n\t  if (Buffer.isBuffer(content)) content = content.toString('utf8')\n\t  content = content.replace(/^\\uFEFF/, '')\n\t  return content\n\t}\n\t\n\tvar jsonfile = {\n\t  spaces: null,\n\t  readFile: readFile,\n\t  readFileSync: readFileSync,\n\t  writeFile: writeFile,\n\t  writeFileSync: writeFileSync\n\t}\n\t\n\tmodule.exports = jsonfile\n\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar fs = __webpack_require__(15)\n\tvar polyfills = __webpack_require__(23)\n\tvar legacy = __webpack_require__(26)\n\tvar queue = []\n\t\n\tvar util = __webpack_require__(28)\n\t\n\tfunction noop () {}\n\t\n\tvar debug = noop\n\tif (util.debuglog)\n\t  debug = util.debuglog('gfs4')\n\telse if (/\\bgfs4\\b/i.test(process.env.NODE_DEBUG || ''))\n\t  debug = function() {\n\t    var m = util.format.apply(util, arguments)\n\t    m = 'GFS4: ' + m.split(/\\n/).join('\\nGFS4: ')\n\t    console.error(m)\n\t  }\n\t\n\tif (/\\bgfs4\\b/i.test(process.env.NODE_DEBUG || '')) {\n\t  process.on('exit', function() {\n\t    debug(queue)\n\t    __webpack_require__(29).equal(queue.length, 0)\n\t  })\n\t}\n\t\n\tmodule.exports = patch(__webpack_require__(24))\n\tif (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH) {\n\t  module.exports = patch(fs)\n\t}\n\t\n\t// Always patch fs.close/closeSync, because we want to\n\t// retry() whenever a close happens *anywhere* in the program.\n\t// This is essential when multiple graceful-fs instances are\n\t// in play at the same time.\n\tmodule.exports.close =\n\tfs.close = (function (fs$close) { return function (fd, cb) {\n\t  return fs$close.call(fs, fd, function (err) {\n\t    if (!err)\n\t      retry()\n\t\n\t    if (typeof cb === 'function')\n\t      cb.apply(this, arguments)\n\t  })\n\t}})(fs.close)\n\t\n\tmodule.exports.closeSync =\n\tfs.closeSync = (function (fs$closeSync) { return function (fd) {\n\t  // Note that graceful-fs also retries when fs.closeSync() fails.\n\t  // Looks like a bug to me, although it's probably a harmless one.\n\t  var rval = fs$closeSync.apply(fs, arguments)\n\t  retry()\n\t  return rval\n\t}})(fs.closeSync)\n\t\n\tfunction patch (fs) {\n\t  // Everything that references the open() function needs to be in here\n\t  polyfills(fs)\n\t  fs.gracefulify = patch\n\t  fs.FileReadStream = ReadStream;  // Legacy name.\n\t  fs.FileWriteStream = WriteStream;  // Legacy name.\n\t  fs.createReadStream = createReadStream\n\t  fs.createWriteStream = createWriteStream\n\t  var fs$readFile = fs.readFile\n\t  fs.readFile = readFile\n\t  function readFile (path, options, cb) {\n\t    if (typeof options === 'function')\n\t      cb = options, options = null\n\t\n\t    return go$readFile(path, options, cb)\n\t\n\t    function go$readFile (path, options, cb) {\n\t      return fs$readFile(path, options, function (err) {\n\t        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n\t          enqueue([go$readFile, [path, options, cb]])\n\t        else {\n\t          if (typeof cb === 'function')\n\t            cb.apply(this, arguments)\n\t          retry()\n\t        }\n\t      })\n\t    }\n\t  }\n\t\n\t  var fs$writeFile = fs.writeFile\n\t  fs.writeFile = writeFile\n\t  function writeFile (path, data, options, cb) {\n\t    if (typeof options === 'function')\n\t      cb = options, options = null\n\t\n\t    return go$writeFile(path, data, options, cb)\n\t\n\t    function go$writeFile (path, data, options, cb) {\n\t      return fs$writeFile(path, data, options, function (err) {\n\t        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n\t          enqueue([go$writeFile, [path, data, options, cb]])\n\t        else {\n\t          if (typeof cb === 'function')\n\t            cb.apply(this, arguments)\n\t          retry()\n\t        }\n\t      })\n\t    }\n\t  }\n\t\n\t  var fs$appendFile = fs.appendFile\n\t  if (fs$appendFile)\n\t    fs.appendFile = appendFile\n\t  function appendFile (path, data, options, cb) {\n\t    if (typeof options === 'function')\n\t      cb = options, options = null\n\t\n\t    return go$appendFile(path, data, options, cb)\n\t\n\t    function go$appendFile (path, data, options, cb) {\n\t      return fs$appendFile(path, data, options, function (err) {\n\t        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n\t          enqueue([go$appendFile, [path, data, options, cb]])\n\t        else {\n\t          if (typeof cb === 'function')\n\t            cb.apply(this, arguments)\n\t          retry()\n\t        }\n\t      })\n\t    }\n\t  }\n\t\n\t  var fs$readdir = fs.readdir\n\t  fs.readdir = readdir\n\t  function readdir (path, options, cb) {\n\t    var args = [path]\n\t    if (typeof options !== 'function') {\n\t      args.push(options)\n\t    } else {\n\t      cb = options\n\t    }\n\t    args.push(go$readdir$cb)\n\t\n\t    return go$readdir(args)\n\t\n\t    function go$readdir$cb (err, files) {\n\t      if (files && files.sort)\n\t        files.sort()\n\t\n\t      if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n\t        enqueue([go$readdir, [args]])\n\t      else {\n\t        if (typeof cb === 'function')\n\t          cb.apply(this, arguments)\n\t        retry()\n\t      }\n\t    }\n\t  }\n\t\n\t  function go$readdir (args) {\n\t    return fs$readdir.apply(fs, args)\n\t  }\n\t\n\t  if (process.version.substr(0, 4) === 'v0.8') {\n\t    var legStreams = legacy(fs)\n\t    ReadStream = legStreams.ReadStream\n\t    WriteStream = legStreams.WriteStream\n\t  }\n\t\n\t  var fs$ReadStream = fs.ReadStream\n\t  ReadStream.prototype = Object.create(fs$ReadStream.prototype)\n\t  ReadStream.prototype.open = ReadStream$open\n\t\n\t  var fs$WriteStream = fs.WriteStream\n\t  WriteStream.prototype = Object.create(fs$WriteStream.prototype)\n\t  WriteStream.prototype.open = WriteStream$open\n\t\n\t  fs.ReadStream = ReadStream\n\t  fs.WriteStream = WriteStream\n\t\n\t  function ReadStream (path, options) {\n\t    if (this instanceof ReadStream)\n\t      return fs$ReadStream.apply(this, arguments), this\n\t    else\n\t      return ReadStream.apply(Object.create(ReadStream.prototype), arguments)\n\t  }\n\t\n\t  function ReadStream$open () {\n\t    var that = this\n\t    open(that.path, that.flags, that.mode, function (err, fd) {\n\t      if (err) {\n\t        if (that.autoClose)\n\t          that.destroy()\n\t\n\t        that.emit('error', err)\n\t      } else {\n\t        that.fd = fd\n\t        that.emit('open', fd)\n\t        that.read()\n\t      }\n\t    })\n\t  }\n\t\n\t  function WriteStream (path, options) {\n\t    if (this instanceof WriteStream)\n\t      return fs$WriteStream.apply(this, arguments), this\n\t    else\n\t      return WriteStream.apply(Object.create(WriteStream.prototype), arguments)\n\t  }\n\t\n\t  function WriteStream$open () {\n\t    var that = this\n\t    open(that.path, that.flags, that.mode, function (err, fd) {\n\t      if (err) {\n\t        that.destroy()\n\t        that.emit('error', err)\n\t      } else {\n\t        that.fd = fd\n\t        that.emit('open', fd)\n\t      }\n\t    })\n\t  }\n\t\n\t  function createReadStream (path, options) {\n\t    return new ReadStream(path, options)\n\t  }\n\t\n\t  function createWriteStream (path, options) {\n\t    return new WriteStream(path, options)\n\t  }\n\t\n\t  var fs$open = fs.open\n\t  fs.open = open\n\t  function open (path, flags, mode, cb) {\n\t    if (typeof mode === 'function')\n\t      cb = mode, mode = null\n\t\n\t    return go$open(path, flags, mode, cb)\n\t\n\t    function go$open (path, flags, mode, cb) {\n\t      return fs$open(path, flags, mode, function (err, fd) {\n\t        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n\t          enqueue([go$open, [path, flags, mode, cb]])\n\t        else {\n\t          if (typeof cb === 'function')\n\t            cb.apply(this, arguments)\n\t          retry()\n\t        }\n\t      })\n\t    }\n\t  }\n\t\n\t  return fs\n\t}\n\t\n\tfunction enqueue (elem) {\n\t  debug('ENQUEUE', elem[0].name, elem[1])\n\t  queue.push(elem)\n\t}\n\t\n\tfunction retry () {\n\t  var elem = queue.shift()\n\t  if (elem) {\n\t    debug('RETRY', elem[0].name, elem[1])\n\t    elem[0].apply(null, elem[1])\n\t  }\n\t}\n\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar fs = __webpack_require__(24)\n\tvar constants = __webpack_require__(25)\n\t\n\tvar origCwd = process.cwd\n\tvar cwd = null\n\t\n\tvar platform = process.env.GRACEFUL_FS_PLATFORM || process.platform\n\t\n\tprocess.cwd = function() {\n\t  if (!cwd)\n\t    cwd = origCwd.call(process)\n\t  return cwd\n\t}\n\ttry {\n\t  process.cwd()\n\t} catch (er) {}\n\t\n\tvar chdir = process.chdir\n\tprocess.chdir = function(d) {\n\t  cwd = null\n\t  chdir.call(process, d)\n\t}\n\t\n\tmodule.exports = patch\n\t\n\tfunction patch (fs) {\n\t  // (re-)implement some things that are known busted or missing.\n\t\n\t  // lchmod, broken prior to 0.6.2\n\t  // back-port the fix here.\n\t  if (constants.hasOwnProperty('O_SYMLINK') &&\n\t      process.version.match(/^v0\\.6\\.[0-2]|^v0\\.5\\./)) {\n\t    patchLchmod(fs)\n\t  }\n\t\n\t  // lutimes implementation, or no-op\n\t  if (!fs.lutimes) {\n\t    patchLutimes(fs)\n\t  }\n\t\n\t  // https://github.com/isaacs/node-graceful-fs/issues/4\n\t  // Chown should not fail on einval or eperm if non-root.\n\t  // It should not fail on enosys ever, as this just indicates\n\t  // that a fs doesn't support the intended operation.\n\t\n\t  fs.chown = chownFix(fs.chown)\n\t  fs.fchown = chownFix(fs.fchown)\n\t  fs.lchown = chownFix(fs.lchown)\n\t\n\t  fs.chmod = chmodFix(fs.chmod)\n\t  fs.fchmod = chmodFix(fs.fchmod)\n\t  fs.lchmod = chmodFix(fs.lchmod)\n\t\n\t  fs.chownSync = chownFixSync(fs.chownSync)\n\t  fs.fchownSync = chownFixSync(fs.fchownSync)\n\t  fs.lchownSync = chownFixSync(fs.lchownSync)\n\t\n\t  fs.chmodSync = chmodFixSync(fs.chmodSync)\n\t  fs.fchmodSync = chmodFixSync(fs.fchmodSync)\n\t  fs.lchmodSync = chmodFixSync(fs.lchmodSync)\n\t\n\t  fs.stat = statFix(fs.stat)\n\t  fs.fstat = statFix(fs.fstat)\n\t  fs.lstat = statFix(fs.lstat)\n\t\n\t  fs.statSync = statFixSync(fs.statSync)\n\t  fs.fstatSync = statFixSync(fs.fstatSync)\n\t  fs.lstatSync = statFixSync(fs.lstatSync)\n\t\n\t  // if lchmod/lchown do not exist, then make them no-ops\n\t  if (!fs.lchmod) {\n\t    fs.lchmod = function (path, mode, cb) {\n\t      if (cb) process.nextTick(cb)\n\t    }\n\t    fs.lchmodSync = function () {}\n\t  }\n\t  if (!fs.lchown) {\n\t    fs.lchown = function (path, uid, gid, cb) {\n\t      if (cb) process.nextTick(cb)\n\t    }\n\t    fs.lchownSync = function () {}\n\t  }\n\t\n\t  // on Windows, A/V software can lock the directory, causing this\n\t  // to fail with an EACCES or EPERM if the directory contains newly\n\t  // created files.  Try again on failure, for up to 60 seconds.\n\t\n\t  // Set the timeout this long because some Windows Anti-Virus, such as Parity\n\t  // bit9, may lock files for up to a minute, causing npm package install\n\t  // failures. Also, take care to yield the scheduler. Windows scheduling gives\n\t  // CPU to a busy looping process, which can cause the program causing the lock\n\t  // contention to be starved of CPU by node, so the contention doesn't resolve.\n\t  if (platform === \"win32\") {\n\t    fs.rename = (function (fs$rename) { return function (from, to, cb) {\n\t      var start = Date.now()\n\t      var backoff = 0;\n\t      fs$rename(from, to, function CB (er) {\n\t        if (er\n\t            && (er.code === \"EACCES\" || er.code === \"EPERM\")\n\t            && Date.now() - start < 60000) {\n\t          setTimeout(function() {\n\t            fs.stat(to, function (stater, st) {\n\t              if (stater && stater.code === \"ENOENT\")\n\t                fs$rename(from, to, CB);\n\t              else\n\t                cb(er)\n\t            })\n\t          }, backoff)\n\t          if (backoff < 100)\n\t            backoff += 10;\n\t          return;\n\t        }\n\t        if (cb) cb(er)\n\t      })\n\t    }})(fs.rename)\n\t  }\n\t\n\t  // if read() returns EAGAIN, then just try it again.\n\t  fs.read = (function (fs$read) { return function (fd, buffer, offset, length, position, callback_) {\n\t    var callback\n\t    if (callback_ && typeof callback_ === 'function') {\n\t      var eagCounter = 0\n\t      callback = function (er, _, __) {\n\t        if (er && er.code === 'EAGAIN' && eagCounter < 10) {\n\t          eagCounter ++\n\t          return fs$read.call(fs, fd, buffer, offset, length, position, callback)\n\t        }\n\t        callback_.apply(this, arguments)\n\t      }\n\t    }\n\t    return fs$read.call(fs, fd, buffer, offset, length, position, callback)\n\t  }})(fs.read)\n\t\n\t  fs.readSync = (function (fs$readSync) { return function (fd, buffer, offset, length, position) {\n\t    var eagCounter = 0\n\t    while (true) {\n\t      try {\n\t        return fs$readSync.call(fs, fd, buffer, offset, length, position)\n\t      } catch (er) {\n\t        if (er.code === 'EAGAIN' && eagCounter < 10) {\n\t          eagCounter ++\n\t          continue\n\t        }\n\t        throw er\n\t      }\n\t    }\n\t  }})(fs.readSync)\n\t}\n\t\n\tfunction patchLchmod (fs) {\n\t  fs.lchmod = function (path, mode, callback) {\n\t    fs.open( path\n\t           , constants.O_WRONLY | constants.O_SYMLINK\n\t           , mode\n\t           , function (err, fd) {\n\t      if (err) {\n\t        if (callback) callback(err)\n\t        return\n\t      }\n\t      // prefer to return the chmod error, if one occurs,\n\t      // but still try to close, and report closing errors if they occur.\n\t      fs.fchmod(fd, mode, function (err) {\n\t        fs.close(fd, function(err2) {\n\t          if (callback) callback(err || err2)\n\t        })\n\t      })\n\t    })\n\t  }\n\t\n\t  fs.lchmodSync = function (path, mode) {\n\t    var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode)\n\t\n\t    // prefer to return the chmod error, if one occurs,\n\t    // but still try to close, and report closing errors if they occur.\n\t    var threw = true\n\t    var ret\n\t    try {\n\t      ret = fs.fchmodSync(fd, mode)\n\t      threw = false\n\t    } finally {\n\t      if (threw) {\n\t        try {\n\t          fs.closeSync(fd)\n\t        } catch (er) {}\n\t      } else {\n\t        fs.closeSync(fd)\n\t      }\n\t    }\n\t    return ret\n\t  }\n\t}\n\t\n\tfunction patchLutimes (fs) {\n\t  if (constants.hasOwnProperty(\"O_SYMLINK\")) {\n\t    fs.lutimes = function (path, at, mt, cb) {\n\t      fs.open(path, constants.O_SYMLINK, function (er, fd) {\n\t        if (er) {\n\t          if (cb) cb(er)\n\t          return\n\t        }\n\t        fs.futimes(fd, at, mt, function (er) {\n\t          fs.close(fd, function (er2) {\n\t            if (cb) cb(er || er2)\n\t          })\n\t        })\n\t      })\n\t    }\n\t\n\t    fs.lutimesSync = function (path, at, mt) {\n\t      var fd = fs.openSync(path, constants.O_SYMLINK)\n\t      var ret\n\t      var threw = true\n\t      try {\n\t        ret = fs.futimesSync(fd, at, mt)\n\t        threw = false\n\t      } finally {\n\t        if (threw) {\n\t          try {\n\t            fs.closeSync(fd)\n\t          } catch (er) {}\n\t        } else {\n\t          fs.closeSync(fd)\n\t        }\n\t      }\n\t      return ret\n\t    }\n\t\n\t  } else {\n\t    fs.lutimes = function (_a, _b, _c, cb) { if (cb) process.nextTick(cb) }\n\t    fs.lutimesSync = function () {}\n\t  }\n\t}\n\t\n\tfunction chmodFix (orig) {\n\t  if (!orig) return orig\n\t  return function (target, mode, cb) {\n\t    return orig.call(fs, target, mode, function (er) {\n\t      if (chownErOk(er)) er = null\n\t      if (cb) cb.apply(this, arguments)\n\t    })\n\t  }\n\t}\n\t\n\tfunction chmodFixSync (orig) {\n\t  if (!orig) return orig\n\t  return function (target, mode) {\n\t    try {\n\t      return orig.call(fs, target, mode)\n\t    } catch (er) {\n\t      if (!chownErOk(er)) throw er\n\t    }\n\t  }\n\t}\n\t\n\t\n\tfunction chownFix (orig) {\n\t  if (!orig) return orig\n\t  return function (target, uid, gid, cb) {\n\t    return orig.call(fs, target, uid, gid, function (er) {\n\t      if (chownErOk(er)) er = null\n\t      if (cb) cb.apply(this, arguments)\n\t    })\n\t  }\n\t}\n\t\n\tfunction chownFixSync (orig) {\n\t  if (!orig) return orig\n\t  return function (target, uid, gid) {\n\t    try {\n\t      return orig.call(fs, target, uid, gid)\n\t    } catch (er) {\n\t      if (!chownErOk(er)) throw er\n\t    }\n\t  }\n\t}\n\t\n\t\n\tfunction statFix (orig) {\n\t  if (!orig) return orig\n\t  // Older versions of Node erroneously returned signed integers for\n\t  // uid + gid.\n\t  return function (target, cb) {\n\t    return orig.call(fs, target, function (er, stats) {\n\t      if (!stats) return cb.apply(this, arguments)\n\t      if (stats.uid < 0) stats.uid += 0x100000000\n\t      if (stats.gid < 0) stats.gid += 0x100000000\n\t      if (cb) cb.apply(this, arguments)\n\t    })\n\t  }\n\t}\n\t\n\tfunction statFixSync (orig) {\n\t  if (!orig) return orig\n\t  // Older versions of Node erroneously returned signed integers for\n\t  // uid + gid.\n\t  return function (target) {\n\t    var stats = orig.call(fs, target)\n\t    if (stats.uid < 0) stats.uid += 0x100000000\n\t    if (stats.gid < 0) stats.gid += 0x100000000\n\t    return stats;\n\t  }\n\t}\n\t\n\t// ENOSYS means that the fs doesn't support the op. Just ignore\n\t// that, because it doesn't matter.\n\t//\n\t// if there's no getuid, or if getuid() is something other\n\t// than 0, and the error is EINVAL or EPERM, then just ignore\n\t// it.\n\t//\n\t// This specific case is a silent failure in cp, install, tar,\n\t// and most other unix tools that manage permissions.\n\t//\n\t// When running as root, or if other types of errors are\n\t// encountered, then it's strict.\n\tfunction chownErOk (er) {\n\t  if (!er)\n\t    return true\n\t\n\t  if (er.code === \"ENOSYS\")\n\t    return true\n\t\n\t  var nonroot = !process.getuid || process.getuid() !== 0\n\t  if (nonroot) {\n\t    if (er.code === \"EINVAL\" || er.code === \"EPERM\")\n\t      return true\n\t  }\n\t\n\t  return false\n\t}\n\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict'\n\t\n\tvar fs = __webpack_require__(15)\n\t\n\tmodule.exports = clone(fs)\n\t\n\tfunction clone (obj) {\n\t  if (obj === null || typeof obj !== 'object')\n\t    return obj\n\t\n\t  if (obj instanceof Object)\n\t    var copy = { __proto__: obj.__proto__ }\n\t  else\n\t    var copy = Object.create(null)\n\t\n\t  Object.getOwnPropertyNames(obj).forEach(function (key) {\n\t    Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key))\n\t  })\n\t\n\t  return copy\n\t}\n\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports) {\n\n\tmodule.exports = require(\"constants\");\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Stream = __webpack_require__(27).Stream\n\t\n\tmodule.exports = legacy\n\t\n\tfunction legacy (fs) {\n\t  return {\n\t    ReadStream: ReadStream,\n\t    WriteStream: WriteStream\n\t  }\n\t\n\t  function ReadStream (path, options) {\n\t    if (!(this instanceof ReadStream)) return new ReadStream(path, options);\n\t\n\t    Stream.call(this);\n\t\n\t    var self = this;\n\t\n\t    this.path = path;\n\t    this.fd = null;\n\t    this.readable = true;\n\t    this.paused = false;\n\t\n\t    this.flags = 'r';\n\t    this.mode = 438; /*=0666*/\n\t    this.bufferSize = 64 * 1024;\n\t\n\t    options = options || {};\n\t\n\t    // Mixin options into this\n\t    var keys = Object.keys(options);\n\t    for (var index = 0, length = keys.length; index < length; index++) {\n\t      var key = keys[index];\n\t      this[key] = options[key];\n\t    }\n\t\n\t    if (this.encoding) this.setEncoding(this.encoding);\n\t\n\t    if (this.start !== undefined) {\n\t      if ('number' !== typeof this.start) {\n\t        throw TypeError('start must be a Number');\n\t      }\n\t      if (this.end === undefined) {\n\t        this.end = Infinity;\n\t      } else if ('number' !== typeof this.end) {\n\t        throw TypeError('end must be a Number');\n\t      }\n\t\n\t      if (this.start > this.end) {\n\t        throw new Error('start must be <= end');\n\t      }\n\t\n\t      this.pos = this.start;\n\t    }\n\t\n\t    if (this.fd !== null) {\n\t      process.nextTick(function() {\n\t        self._read();\n\t      });\n\t      return;\n\t    }\n\t\n\t    fs.open(this.path, this.flags, this.mode, function (err, fd) {\n\t      if (err) {\n\t        self.emit('error', err);\n\t        self.readable = false;\n\t        return;\n\t      }\n\t\n\t      self.fd = fd;\n\t      self.emit('open', fd);\n\t      self._read();\n\t    })\n\t  }\n\t\n\t  function WriteStream (path, options) {\n\t    if (!(this instanceof WriteStream)) return new WriteStream(path, options);\n\t\n\t    Stream.call(this);\n\t\n\t    this.path = path;\n\t    this.fd = null;\n\t    this.writable = true;\n\t\n\t    this.flags = 'w';\n\t    this.encoding = 'binary';\n\t    this.mode = 438; /*=0666*/\n\t    this.bytesWritten = 0;\n\t\n\t    options = options || {};\n\t\n\t    // Mixin options into this\n\t    var keys = Object.keys(options);\n\t    for (var index = 0, length = keys.length; index < length; index++) {\n\t      var key = keys[index];\n\t      this[key] = options[key];\n\t    }\n\t\n\t    if (this.start !== undefined) {\n\t      if ('number' !== typeof this.start) {\n\t        throw TypeError('start must be a Number');\n\t      }\n\t      if (this.start < 0) {\n\t        throw new Error('start must be >= zero');\n\t      }\n\t\n\t      this.pos = this.start;\n\t    }\n\t\n\t    this.busy = false;\n\t    this._queue = [];\n\t\n\t    if (this.fd === null) {\n\t      this._open = fs.open;\n\t      this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);\n\t      this.flush();\n\t    }\n\t  }\n\t}\n\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports) {\n\n\tmodule.exports = require(\"stream\");\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports) {\n\n\tmodule.exports = require(\"util\");\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports) {\n\n\tmodule.exports = require(\"assert\");\n\n/***/ }),\n/* 30 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar path = __webpack_require__(14);\n\tvar fs = __webpack_require__(15);\n\tvar _0777 = parseInt('0777', 8);\n\t\n\tmodule.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;\n\t\n\tfunction mkdirP (p, opts, f, made) {\n\t    if (typeof opts === 'function') {\n\t        f = opts;\n\t        opts = {};\n\t    }\n\t    else if (!opts || typeof opts !== 'object') {\n\t        opts = { mode: opts };\n\t    }\n\t    \n\t    var mode = opts.mode;\n\t    var xfs = opts.fs || fs;\n\t    \n\t    if (mode === undefined) {\n\t        mode = _0777 & (~process.umask());\n\t    }\n\t    if (!made) made = null;\n\t    \n\t    var cb = f || function () {};\n\t    p = path.resolve(p);\n\t    \n\t    xfs.mkdir(p, mode, function (er) {\n\t        if (!er) {\n\t            made = made || p;\n\t            return cb(null, made);\n\t        }\n\t        switch (er.code) {\n\t            case 'ENOENT':\n\t                mkdirP(path.dirname(p), opts, function (er, made) {\n\t                    if (er) cb(er, made);\n\t                    else mkdirP(p, opts, cb, made);\n\t                });\n\t                break;\n\t\n\t            // In the case of any other error, just see if there's a dir\n\t            // there already.  If so, then hooray!  If not, then something\n\t            // is borked.\n\t            default:\n\t                xfs.stat(p, function (er2, stat) {\n\t                    // if the stat fails, then that's super weird.\n\t                    // let the original error be the failure reason.\n\t                    if (er2 || !stat.isDirectory()) cb(er, made)\n\t                    else cb(null, made);\n\t                });\n\t                break;\n\t        }\n\t    });\n\t}\n\t\n\tmkdirP.sync = function sync (p, opts, made) {\n\t    if (!opts || typeof opts !== 'object') {\n\t        opts = { mode: opts };\n\t    }\n\t    \n\t    var mode = opts.mode;\n\t    var xfs = opts.fs || fs;\n\t    \n\t    if (mode === undefined) {\n\t        mode = _0777 & (~process.umask());\n\t    }\n\t    if (!made) made = null;\n\t\n\t    p = path.resolve(p);\n\t\n\t    try {\n\t        xfs.mkdirSync(p, mode);\n\t        made = made || p;\n\t    }\n\t    catch (err0) {\n\t        switch (err0.code) {\n\t            case 'ENOENT' :\n\t                made = sync(path.dirname(p), opts, made);\n\t                sync(p, opts, made);\n\t                break;\n\t\n\t            // In the case of any other error, just see if there's a dir\n\t            // there already.  If so, then hooray!  If not, then something\n\t            // is borked.\n\t            default:\n\t                var stat;\n\t                try {\n\t                    stat = xfs.statSync(p);\n\t                }\n\t                catch (err1) {\n\t                    throw err0;\n\t                }\n\t                if (!stat.isDirectory()) throw err0;\n\t                break;\n\t        }\n\t    }\n\t\n\t    return made;\n\t};\n\n\n/***/ }),\n/* 31 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar pSlice = Array.prototype.slice;\n\tvar objectKeys = __webpack_require__(32);\n\tvar isArguments = __webpack_require__(33);\n\t\n\tvar deepEqual = module.exports = function (actual, expected, opts) {\n\t  if (!opts) opts = {};\n\t  // 7.1. All identical values are equivalent, as determined by ===.\n\t  if (actual === expected) {\n\t    return true;\n\t\n\t  } else if (actual instanceof Date && expected instanceof Date) {\n\t    return actual.getTime() === expected.getTime();\n\t\n\t  // 7.3. Other pairs that do not both pass typeof value == 'object',\n\t  // equivalence is determined by ==.\n\t  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {\n\t    return opts.strict ? actual === expected : actual == expected;\n\t\n\t  // 7.4. For all other Object pairs, including Array objects, equivalence is\n\t  // determined by having the same number of owned properties (as verified\n\t  // with Object.prototype.hasOwnProperty.call), the same set of keys\n\t  // (although not necessarily the same order), equivalent values for every\n\t  // corresponding key, and an identical 'prototype' property. Note: this\n\t  // accounts for both named and indexed properties on Arrays.\n\t  } else {\n\t    return objEquiv(actual, expected, opts);\n\t  }\n\t}\n\t\n\tfunction isUndefinedOrNull(value) {\n\t  return value === null || value === undefined;\n\t}\n\t\n\tfunction isBuffer (x) {\n\t  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;\n\t  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {\n\t    return false;\n\t  }\n\t  if (x.length > 0 && typeof x[0] !== 'number') return false;\n\t  return true;\n\t}\n\t\n\tfunction objEquiv(a, b, opts) {\n\t  var i, key;\n\t  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))\n\t    return false;\n\t  // an identical 'prototype' property.\n\t  if (a.prototype !== b.prototype) return false;\n\t  //~~~I've managed to break Object.keys through screwy arguments passing.\n\t  //   Converting to array solves the problem.\n\t  if (isArguments(a)) {\n\t    if (!isArguments(b)) {\n\t      return false;\n\t    }\n\t    a = pSlice.call(a);\n\t    b = pSlice.call(b);\n\t    return deepEqual(a, b, opts);\n\t  }\n\t  if (isBuffer(a)) {\n\t    if (!isBuffer(b)) {\n\t      return false;\n\t    }\n\t    if (a.length !== b.length) return false;\n\t    for (i = 0; i < a.length; i++) {\n\t      if (a[i] !== b[i]) return false;\n\t    }\n\t    return true;\n\t  }\n\t  try {\n\t    var ka = objectKeys(a),\n\t        kb = objectKeys(b);\n\t  } catch (e) {//happens when one is a string literal and the other isn't\n\t    return false;\n\t  }\n\t  // having the same number of owned properties (keys incorporates\n\t  // hasOwnProperty)\n\t  if (ka.length != kb.length)\n\t    return false;\n\t  //the same set of keys (although not necessarily the same order),\n\t  ka.sort();\n\t  kb.sort();\n\t  //~~~cheap key test\n\t  for (i = ka.length - 1; i >= 0; i--) {\n\t    if (ka[i] != kb[i])\n\t      return false;\n\t  }\n\t  //equivalent values for every corresponding key, and\n\t  //~~~possibly expensive deep test\n\t  for (i = ka.length - 1; i >= 0; i--) {\n\t    key = ka[i];\n\t    if (!deepEqual(a[key], b[key], opts)) return false;\n\t  }\n\t  return typeof a === typeof b;\n\t}\n\n\n/***/ }),\n/* 32 */\n/***/ (function(module, exports) {\n\n\texports = module.exports = typeof Object.keys === 'function'\n\t  ? Object.keys : shim;\n\t\n\texports.shim = shim;\n\tfunction shim (obj) {\n\t  var keys = [];\n\t  for (var key in obj) keys.push(key);\n\t  return keys;\n\t}\n\n\n/***/ }),\n/* 33 */\n/***/ (function(module, exports) {\n\n\tvar supportsArgumentsClass = (function(){\n\t  return Object.prototype.toString.call(arguments)\n\t})() == '[object Arguments]';\n\t\n\texports = module.exports = supportsArgumentsClass ? supported : unsupported;\n\t\n\texports.supported = supported;\n\tfunction supported(object) {\n\t  return Object.prototype.toString.call(object) == '[object Arguments]';\n\t};\n\t\n\texports.unsupported = unsupported;\n\tfunction unsupported(object){\n\t  return object &&\n\t    typeof object == 'object' &&\n\t    typeof object.length == 'number' &&\n\t    Object.prototype.hasOwnProperty.call(object, 'callee') &&\n\t    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||\n\t    false;\n\t};\n\n\n/***/ }),\n/* 34 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _wurl = __webpack_require__(35);\n\t\n\tvar _wurl2 = _interopRequireDefault(_wurl);\n\t\n\tvar _os = __webpack_require__(36);\n\t\n\tvar _os2 = _interopRequireDefault(_os);\n\t\n\tvar _fs = __webpack_require__(15);\n\t\n\tvar _fs2 = _interopRequireDefault(_fs);\n\t\n\tvar _path = __webpack_require__(14);\n\t\n\tvar _path2 = _interopRequireDefault(_path);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar INJECT_CSS_PATH = _path2.default.join(__dirname, '..', 'inject/inject.css');\n\t\n\tfunction isOSX() {\n\t    return _os2.default.platform() === 'darwin';\n\t}\n\t\n\tfunction isLinux() {\n\t    return _os2.default.platform() === 'linux';\n\t}\n\t\n\tfunction isWindows() {\n\t    return _os2.default.platform() === 'win32';\n\t}\n\t\n\tfunction linkIsInternal(currentUrl, newUrl, internalUrlRegex) {\n\t    if (internalUrlRegex) {\n\t        var regex = RegExp(internalUrlRegex);\n\t        return regex.test(newUrl);\n\t    }\n\t\n\t    var currentDomain = (0, _wurl2.default)('domain', currentUrl);\n\t    var newDomain = (0, _wurl2.default)('domain', newUrl);\n\t    return currentDomain === newDomain;\n\t}\n\t\n\tfunction shouldInjectCss() {\n\t    try {\n\t        _fs2.default.accessSync(INJECT_CSS_PATH, _fs2.default.F_OK);\n\t        return true;\n\t    } catch (e) {\n\t        return false;\n\t    }\n\t}\n\t\n\tfunction getCssToInject() {\n\t    return _fs2.default.readFileSync(INJECT_CSS_PATH).toString();\n\t}\n\t\n\t/**\n\t * Helper method to print debug messages from the main process in the browser window\n\t * @param {BrowserWindow} browserWindow\n\t * @param message\n\t */\n\tfunction debugLog(browserWindow, message) {\n\t    // need the timeout as it takes time for the preload javascript to be loaded in the window\n\t    setTimeout(function () {\n\t        browserWindow.webContents.send('debug', message);\n\t    }, 3000);\n\t    console.log(message);\n\t}\n\t\n\texports.default = {\n\t    isOSX: isOSX,\n\t    isLinux: isLinux,\n\t    isWindows: isWindows,\n\t    linkIsInternal: linkIsInternal,\n\t    getCssToInject: getCssToInject,\n\t    debugLog: debugLog,\n\t    shouldInjectCss: shouldInjectCss\n\t};\n\n/***/ }),\n/* 35 */\n/***/ (function(module, exports) {\n\n\tmodule.exports = function (arg, url) {\r\n\t\r\n\t    function _t() {\r\n\t        return new RegExp(/(.*?)\\.?([^\\.]*?)\\.?(com|net|org|biz|ws|in|me|co\\.uk|co|org\\.uk|ltd\\.uk|plc\\.uk|me\\.uk|edu|mil|br\\.com|cn\\.com|eu\\.com|hu\\.com|no\\.com|qc\\.com|sa\\.com|se\\.com|se\\.net|us\\.com|uy\\.com|ac|co\\.ac|gv\\.ac|or\\.ac|ac\\.ac|af|am|as|at|ac\\.at|co\\.at|gv\\.at|or\\.at|asn\\.au|com\\.au|edu\\.au|org\\.au|net\\.au|id\\.au|be|ac\\.be|adm\\.br|adv\\.br|am\\.br|arq\\.br|art\\.br|bio\\.br|cng\\.br|cnt\\.br|com\\.br|ecn\\.br|eng\\.br|esp\\.br|etc\\.br|eti\\.br|fm\\.br|fot\\.br|fst\\.br|g12\\.br|gov\\.br|ind\\.br|inf\\.br|jor\\.br|lel\\.br|med\\.br|mil\\.br|net\\.br|nom\\.br|ntr\\.br|odo\\.br|org\\.br|ppg\\.br|pro\\.br|psc\\.br|psi\\.br|rec\\.br|slg\\.br|tmp\\.br|tur\\.br|tv\\.br|vet\\.br|zlg\\.br|br|ab\\.ca|bc\\.ca|mb\\.ca|nb\\.ca|nf\\.ca|ns\\.ca|nt\\.ca|on\\.ca|pe\\.ca|qc\\.ca|sk\\.ca|yk\\.ca|ca|cc|ac\\.cn|com\\.cn|edu\\.cn|gov\\.cn|org\\.cn|bj\\.cn|sh\\.cn|tj\\.cn|cq\\.cn|he\\.cn|nm\\.cn|ln\\.cn|jl\\.cn|hl\\.cn|js\\.cn|zj\\.cn|ah\\.cn|gd\\.cn|gx\\.cn|hi\\.cn|sc\\.cn|gz\\.cn|yn\\.cn|xz\\.cn|sn\\.cn|gs\\.cn|qh\\.cn|nx\\.cn|xj\\.cn|tw\\.cn|hk\\.cn|mo\\.cn|cn|cx|cz|de|dk|fo|com\\.ec|tm\\.fr|com\\.fr|asso\\.fr|presse\\.fr|fr|gf|gs|co\\.il|net\\.il|ac\\.il|k12\\.il|gov\\.il|muni\\.il|ac\\.in|co\\.in|org\\.in|ernet\\.in|gov\\.in|net\\.in|res\\.in|is|it|ac\\.jp|co\\.jp|go\\.jp|or\\.jp|ne\\.jp|ac\\.kr|co\\.kr|go\\.kr|ne\\.kr|nm\\.kr|or\\.kr|li|lt|lu|asso\\.mc|tm\\.mc|com\\.mm|org\\.mm|net\\.mm|edu\\.mm|gov\\.mm|ms|nl|no|nu|pl|ro|org\\.ro|store\\.ro|tm\\.ro|firm\\.ro|www\\.ro|arts\\.ro|rec\\.ro|info\\.ro|nom\\.ro|nt\\.ro|se|si|com\\.sg|org\\.sg|net\\.sg|gov\\.sg|sk|st|tf|ac\\.th|co\\.th|go\\.th|mi\\.th|net\\.th|or\\.th|tm|to|com\\.tr|edu\\.tr|gov\\.tr|k12\\.tr|net\\.tr|org\\.tr|com\\.tw|org\\.tw|net\\.tw|ac\\.uk|uk\\.com|uk\\.net|gb\\.com|gb\\.net|vg|sh|kz|ch|info|ua|gov|name|pro|ie|hk|com\\.hk|org\\.hk|net\\.hk|edu\\.hk|us|tk|cd|by|ad|lv|eu\\.lv|bz|es|jp|cl|ag|mobi|eu|co\\.nz|org\\.nz|net\\.nz|maori\\.nz|iwi\\.nz|io|la|md|sc|sg|vc|tw|travel|my|se|tv|pt|com\\.pt|edu\\.pt|asia|fi|com\\.ve|net\\.ve|fi|org\\.ve|web\\.ve|info\\.ve|co\\.ve|tel|im|gr|ru|net\\.ru|org\\.ru|hr|com\\.hr|ly|xyz)$/);\r\n\t    }\r\n\t\r\n\t    function _d(s) {\r\n\t      return decodeURIComponent(s.replace(/\\+/g, ' '));\r\n\t    }\r\n\t\r\n\t    function _i(arg, str) {\r\n\t        var sptr = arg.charAt(0),\r\n\t            split = str.split(sptr);\r\n\t\r\n\t        if (sptr === arg) { return split; }\r\n\t\r\n\t        arg = parseInt(arg.substring(1), 10);\r\n\t\r\n\t        return split[arg < 0 ? split.length + arg : arg - 1];\r\n\t    }\r\n\t\r\n\t    function _f(arg, str) {\r\n\t        var sptr = arg.charAt(0),\r\n\t            split = str.split('&'),\r\n\t            field = [],\r\n\t            params = {},\r\n\t            tmp = [],\r\n\t            arg2 = arg.substring(1);\r\n\t\r\n\t        for (var i in split) {\r\n\t            field = split[i].split(/=(.*)/);\r\n\t\r\n\t            if (field[0].replace(/\\s/g, '') !== '') {\r\n\t                field[1] = _d(field[1] || '');\r\n\t\r\n\t                // If we have a match just return it right away.\r\n\t                if (arg2 === field[0]) { return field[1]; }\r\n\t\r\n\t                // Check for array pattern.\r\n\t                tmp = field[0].match(/(.*)\\[([0-9]+)\\]/);\r\n\t\r\n\t                if (tmp) {\r\n\t                    params[tmp[1]] = params[tmp[1]] || [];\r\n\t                \r\n\t                    params[tmp[1]][tmp[2]] = field[1];\r\n\t                }\r\n\t                else {\r\n\t                    params[field[0]] = field[1];    \r\n\t                }\r\n\t            }\r\n\t        }\r\n\t\r\n\t        if (sptr === arg) { return params; }\r\n\t\r\n\t        return params[arg2];\r\n\t    }\r\n\t\r\n\t    //return function(arg, url) {\r\n\t    var _l = {}, tmp, tmp2;\r\n\t\r\n\t    if (arg === 'tld?') { return _t(); }\r\n\t\r\n\t    url = url || window.location.toString();\r\n\t\r\n\t    if ( ! arg) { return url; }\r\n\t\r\n\t    arg = arg.toString();\r\n\t\r\n\t    if (url.match(/^mailto:[^\\/]/)) {\r\n\t        _l.protocol = 'mailto';\r\n\t        _l.email = url.split(/mailto\\:/)[1];\r\n\t    }\r\n\t    else {\r\n\t\r\n\t        // Anchor.\r\n\t        tmp = url.split(/#(.*)/);\r\n\t        _l.hash = tmp[1] ? tmp[1] : undefined;\r\n\t\r\n\t        // Return anchor parts.\r\n\t        if (_l.hash && arg.match(/^#/)) { return _f(arg, _l.hash); }\r\n\t        \r\n\t        // Query\r\n\t        tmp = tmp[0].split(/\\?(.*)/);\r\n\t        _l.query = tmp[1] ? tmp[1] : undefined;\r\n\t\r\n\t        // Return query parts.\r\n\t        if (_l.query && arg.match(/^\\?/)) { return _f(arg, _l.query); }\r\n\t\r\n\t        // Protocol.\r\n\t        tmp = tmp[0].split(/\\:?\\/\\//);\r\n\t        _l.protocol = tmp[1] ? tmp[0].toLowerCase() : undefined;\r\n\t\r\n\t        // Path.\r\n\t        tmp = (tmp[1] ? tmp[1] : tmp[0]).split(/(\\/.*)/);\r\n\t        _l.path = tmp[1] ? tmp[1] : '';\r\n\t\r\n\t        // Clean up path.\r\n\t        _l.path = _l.path.replace(/^([^\\/])/, '/$1').replace(/\\/$/, '');\r\n\t\r\n\t        // Return path parts.\r\n\t        if (arg.match(/^[\\-0-9]+$/)) { arg = arg.replace(/^([^\\/])/, '/$1'); }\r\n\t        if (arg.match(/^\\//)) { return _i(arg, _l.path.substring(1)); }\r\n\t\r\n\t        // File.\r\n\t        tmp2 = _i('/-1', _l.path.substring(1));\r\n\t        tmp2 = tmp2.split(/\\.(.*)/);\r\n\t\r\n\t        // Filename and fileext.\r\n\t        if (tmp2[1]) {\r\n\t            _l.file = tmp2[0] + '.' + tmp2[1];\r\n\t            _l.filename = tmp2[0];\r\n\t            _l.fileext = tmp2[1];\r\n\t        }\r\n\t\r\n\t        // Port.\r\n\t        tmp = tmp[0].split(/\\:([0-9]+)$/);\r\n\t        _l.port = tmp[1] ? tmp[1] : undefined;\r\n\t\r\n\t        // Auth.\r\n\t        tmp = tmp[0].split(/@/);\r\n\t        _l.auth = tmp[1] ? tmp[0] : undefined;\r\n\t\r\n\t        // User and pass.\r\n\t        if (_l.auth) {\r\n\t            tmp2 = _l.auth.split(/\\:(.*)/);\r\n\t            _l.user = tmp2[0];\r\n\t            _l.pass = tmp2[1];\r\n\t        }\r\n\t\r\n\t        // Hostname.\r\n\t        _l.hostname = (tmp[1] ? tmp[1] : tmp[0]).toLowerCase();\r\n\t\r\n\t        // Return hostname parts.\r\n\t        if (arg.charAt(0) === '.') { return _i(arg, _l.hostname); }\r\n\t\r\n\t        // Domain, tld and sub domain.\r\n\t        if (_t()) {\r\n\t            tmp = _l.hostname.match(_t());\r\n\t\r\n\t            if (tmp) {\r\n\t                _l.tld = tmp[3];\r\n\t                _l.domain = tmp[2] ? tmp[2] + '.' + tmp[3] : undefined;\r\n\t                _l.sub = tmp[1] || undefined;\r\n\t            }\r\n\t        }\r\n\t\r\n\t        // Set port and protocol defaults if not set.\r\n\t        _l.port = _l.port || (_l.protocol === 'https' ? '443' : '80');\r\n\t        _l.protocol = _l.protocol || (_l.port === '443' ? 'https' : 'http');\r\n\t    }\r\n\t\r\n\t    // Return arg.\r\n\t    if (arg in _l) { return _l[arg]; }\r\n\t\r\n\t    // Return everything.\r\n\t    if (arg === '{}') { return _l; }\r\n\t\r\n\t    // Default to undefined for no match.\r\n\t    return undefined;\r\n\t    \r\n\t\r\n\t\r\n\t\r\n\t    /*function isNumeric(arg) {\r\n\t      return !isNaN(parseFloat(arg)) && isFinite(arg);\r\n\t    }\r\n\t\r\n\t    function decode(str) {\r\n\t      return decodeURIComponent(str.replace(/\\+/g, ' '));\r\n\t    }\r\n\t    \r\n\t    var _ls = url;\r\n\t\r\n\t    if (!url) { return undefined; }\r\n\t    else if (!arg) { return _ls; }\r\n\t    else { arg = arg.toString(); }\r\n\t\r\n\t    if (_ls.substring(0,2) === '//') { _ls = 'http:' + _ls; }\r\n\t        else if (_ls.split('://').length === 1) { _ls = 'http://' + _ls; }\r\n\t\r\n\t        url = _ls.split('/');\r\n\t        var _l = {auth:''}, host = url[2].split('@');\r\n\t\r\n\t        if (host.length === 1) { host = host[0].split(':'); }\r\n\t        else { _l.auth = host[0]; host = host[1].split(':'); }\r\n\t\r\n\t        _l.protocol=url[0];\r\n\t        _l.hostname=host[0];\r\n\t        _l.port=(host[1] || ((_l.protocol.split(':')[0].toLowerCase() === 'https') ? '443' : '80'));\r\n\t        _l.pathname=( (url.length > 3 ? '/' : '') + url.slice(3, url.length).join('/').split('?')[0].split('#')[0]);\r\n\t        var _p = _l.pathname;\r\n\t\r\n\t        if (_p.charAt(_p.length-1) === '/') { _p=_p.substring(0, _p.length-1); }\r\n\t        var _h = _l.hostname, _hs = _h.split('.'), _ps = _p.split('/');\r\n\t\r\n\t        if (arg === 'hostname') { return _h; }\r\n\t        else if (arg === 'domain') {\r\n\t            if (/^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$/.test(_h)) { return _h; }\r\n\t            return _hs.slice(-2).join('.'); \r\n\t        }\r\n\t        //else if (arg === 'tld') { return _hs.slice(-1).join('.'); }\r\n\t        else if (arg === 'sub') { return _hs.slice(0, _hs.length - 2).join('.'); }\r\n\t        else if (arg === 'port') { return _l.port; }\r\n\t        else if (arg === 'protocol') { return _l.protocol.split(':')[0]; }\r\n\t        else if (arg === 'auth') { return _l.auth; }\r\n\t        else if (arg === 'user') { return _l.auth.split(':')[0]; }\r\n\t        else if (arg === 'pass') { return _l.auth.split(':')[1] || ''; }\r\n\t        else if (arg === 'path') { return _l.pathname; }\r\n\t        else if (arg.charAt(0) === '.')\r\n\t        {\r\n\t            arg = arg.substring(1);\r\n\t            if(isNumeric(arg)) {arg = parseInt(arg, 10); return _hs[arg < 0 ? _hs.length + arg : arg-1] || ''; }\r\n\t        }\r\n\t        else if (isNumeric(arg)) { arg = parseInt(arg, 10); return _ps[arg < 0 ? _ps.length + arg : arg] || ''; }\r\n\t        else if (arg === 'file') { return _ps.slice(-1)[0]; }\r\n\t        else if (arg === 'filename') { return _ps.slice(-1)[0].split('.')[0]; }\r\n\t        else if (arg === 'fileext') { return _ps.slice(-1)[0].split('.')[1] || ''; }\r\n\t        else if (arg.charAt(0) === '?' || arg.charAt(0) === '#')\r\n\t        {\r\n\t            var params = _ls, param = null;\r\n\t\r\n\t            if(arg.charAt(0) === '?') { params = (params.split('?')[1] || '').split('#')[0]; }\r\n\t            else if(arg.charAt(0) === '#') { params = (params.split('#')[1] || ''); }\r\n\t\r\n\t            if(!arg.charAt(1)) { return (params ? decode(params) : params); }\r\n\t\r\n\t            arg = arg.substring(1);\r\n\t            params = params.split('&');\r\n\t\r\n\t            for(var i=0,ii=params.length; i<ii; i++)\r\n\t            {\r\n\t                param = params[i].split(/(.*?)=(.*)/).filter(Boolean);\r\n\t\r\n\t                if(param[0] === arg) { return (param[1] ? decode(param[1]) : param[1]) || ''; }\r\n\t            }\r\n\t\r\n\t            return null;\r\n\t        }\r\n\t\r\n\t    return '';*/\r\n\t};\n\n/***/ }),\n/* 36 */\n/***/ (function(module, exports) {\n\n\tmodule.exports = require(\"os\");\n\n/***/ }),\n/* 37 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _electron = __webpack_require__(17);\n\t\n\t/**\n\t * @param nativefierVersion\n\t * @param appQuit\n\t * @param zoomIn\n\t * @param zoomOut\n\t * @param zoomReset\n\t * @param zoomBuildTimeValue\n\t * @param goBack\n\t * @param goForward\n\t * @param getCurrentUrl\n\t * @param clearAppData\n\t * @param disableDevTools\n\t */\n\tfunction createMenu(_ref) {\n\t    var nativefierVersion = _ref.nativefierVersion,\n\t        appQuit = _ref.appQuit,\n\t        zoomIn = _ref.zoomIn,\n\t        zoomOut = _ref.zoomOut,\n\t        zoomReset = _ref.zoomReset,\n\t        zoomBuildTimeValue = _ref.zoomBuildTimeValue,\n\t        goBack = _ref.goBack,\n\t        goForward = _ref.goForward,\n\t        getCurrentUrl = _ref.getCurrentUrl,\n\t        clearAppData = _ref.clearAppData,\n\t        disableDevTools = _ref.disableDevTools;\n\t\n\t    if (_electron.Menu.getApplicationMenu()) {\n\t        return;\n\t    }\n\t    var zoomResetLabel = zoomBuildTimeValue === 1.0 ? 'Reset Zoom' : 'Reset Zoom (to ' + zoomBuildTimeValue * 100 + '%, set at build time)';\n\t\n\t    var template = [{\n\t        label: 'Edit',\n\t        submenu: [{\n\t            label: 'Undo',\n\t            accelerator: 'CmdOrCtrl+Z',\n\t            role: 'undo'\n\t        }, {\n\t            label: 'Redo',\n\t            accelerator: 'Shift+CmdOrCtrl+Z',\n\t            role: 'redo'\n\t        }, {\n\t            type: 'separator'\n\t        }, {\n\t            label: 'Cut',\n\t            accelerator: 'CmdOrCtrl+X',\n\t            role: 'cut'\n\t        }, {\n\t            label: 'Copy',\n\t            accelerator: 'CmdOrCtrl+C',\n\t            role: 'copy'\n\t        }, {\n\t            label: 'Copy Current URL',\n\t            accelerator: 'CmdOrCtrl+L',\n\t            click: function click() {\n\t                var currentURL = getCurrentUrl();\n\t                _electron.clipboard.writeText(currentURL);\n\t            }\n\t        }, {\n\t            label: 'Paste',\n\t            accelerator: 'CmdOrCtrl+V',\n\t            role: 'paste'\n\t        }, {\n\t            label: 'Select All',\n\t            accelerator: 'CmdOrCtrl+A',\n\t            role: 'selectall'\n\t        }, {\n\t            label: 'Clear App Data',\n\t            click: function click() {\n\t                clearAppData();\n\t            }\n\t        }]\n\t    }, {\n\t        label: 'View',\n\t        submenu: [{\n\t            label: 'Back',\n\t            accelerator: 'CmdOrCtrl+[',\n\t            click: function click() {\n\t                goBack();\n\t            }\n\t        }, {\n\t            label: 'Forward',\n\t            accelerator: 'CmdOrCtrl+]',\n\t            click: function click() {\n\t                goForward();\n\t            }\n\t        }, {\n\t            label: 'Reload',\n\t            accelerator: 'CmdOrCtrl+R',\n\t            click: function click(item, focusedWindow) {\n\t                if (focusedWindow) {\n\t                    focusedWindow.reload();\n\t                }\n\t            }\n\t        }, {\n\t            type: 'separator'\n\t        }, {\n\t            label: 'Toggle Full Screen',\n\t            accelerator: function () {\n\t                if (process.platform === 'darwin') {\n\t                    return 'Ctrl+Command+F';\n\t                }\n\t                return 'F11';\n\t            }(),\n\t            click: function click(item, focusedWindow) {\n\t                if (focusedWindow) {\n\t                    focusedWindow.setFullScreen(!focusedWindow.isFullScreen());\n\t                }\n\t            }\n\t        }, {\n\t            label: 'Zoom In',\n\t            accelerator: function () {\n\t                if (process.platform === 'darwin') {\n\t                    return 'Command+=';\n\t                }\n\t                return 'Ctrl+=';\n\t            }(),\n\t            click: function click() {\n\t                zoomIn();\n\t            }\n\t        }, {\n\t            label: 'Zoom Out',\n\t            accelerator: function () {\n\t                if (process.platform === 'darwin') {\n\t                    return 'Command+-';\n\t                }\n\t                return 'Ctrl+-';\n\t            }(),\n\t            click: function click() {\n\t                zoomOut();\n\t            }\n\t        }, {\n\t            label: zoomResetLabel,\n\t            accelerator: function () {\n\t                if (process.platform === 'darwin') {\n\t                    return 'Command+0';\n\t                }\n\t                return 'Ctrl+0';\n\t            }(),\n\t            click: function click() {\n\t                zoomReset();\n\t            }\n\t        }, {\n\t            label: 'Toggle Developer Tools',\n\t            accelerator: function () {\n\t                if (process.platform === 'darwin') {\n\t                    return 'Alt+Command+I';\n\t                }\n\t                return 'Ctrl+Shift+I';\n\t            }(),\n\t            click: function click(item, focusedWindow) {\n\t                if (focusedWindow) {\n\t                    focusedWindow.toggleDevTools();\n\t                }\n\t            }\n\t        }]\n\t    }, {\n\t        label: 'Window',\n\t        role: 'window',\n\t        submenu: [{\n\t            label: 'Minimize',\n\t            accelerator: 'CmdOrCtrl+M',\n\t            role: 'minimize'\n\t        }, {\n\t            label: 'Close',\n\t            accelerator: 'CmdOrCtrl+W',\n\t            role: 'close'\n\t        }]\n\t    }, {\n\t        label: 'Help',\n\t        role: 'help',\n\t        submenu: [{\n\t            label: 'Built with Nativefier v' + nativefierVersion,\n\t            click: function click() {\n\t                _electron.shell.openExternal('https://github.com/jiahaog/nativefier');\n\t            }\n\t        }, {\n\t            label: 'Report an Issue',\n\t            click: function click() {\n\t                _electron.shell.openExternal('https://github.com/jiahaog/nativefier/issues');\n\t            }\n\t        }]\n\t    }];\n\t\n\t    if (disableDevTools) {\n\t        // remove last item (dev tools) from menu > view\n\t        var submenu = template[1].submenu;\n\t        submenu.splice(submenu.length - 1, 1);\n\t    }\n\t\n\t    if (process.platform === 'darwin') {\n\t        template.unshift({\n\t            label: 'Electron',\n\t            submenu: [{\n\t                label: 'Services',\n\t                role: 'services',\n\t                submenu: []\n\t            }, {\n\t                type: 'separator'\n\t            }, {\n\t                label: 'Hide App',\n\t                accelerator: 'Command+H',\n\t                role: 'hide'\n\t            }, {\n\t                label: 'Hide Others',\n\t                accelerator: 'Command+Shift+H',\n\t                role: 'hideothers'\n\t            }, {\n\t                label: 'Show All',\n\t                role: 'unhide'\n\t            }, {\n\t                type: 'separator'\n\t            }, {\n\t                label: 'Quit',\n\t                accelerator: 'Command+Q',\n\t                click: function click() {\n\t                    appQuit();\n\t                }\n\t            }]\n\t        });\n\t        template[3].submenu.push({\n\t            type: 'separator'\n\t        }, {\n\t            label: 'Bring All to Front',\n\t            role: 'front'\n\t        });\n\t    }\n\t\n\t    var menu = _electron.Menu.buildFromTemplate(template);\n\t    _electron.Menu.setApplicationMenu(menu);\n\t}\n\t\n\texports.default = createMenu;\n\n/***/ }),\n/* 38 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _electron = __webpack_require__(17);\n\t\n\tfunction initContextMenu(mainWindow) {\n\t    _electron.ipcMain.on('contextMenuOpened', function (event, targetHref) {\n\t        var contextMenuTemplate = [{\n\t            label: 'Open with default browser',\n\t            click: function click() {\n\t                if (targetHref) {\n\t                    _electron.shell.openExternal(targetHref);\n\t                    return;\n\t                }\n\t            }\n\t        }, {\n\t            label: 'Open in new window',\n\t            click: function click() {\n\t                if (targetHref) {\n\t                    new _electron.BrowserWindow().loadURL(targetHref);\n\t                    return;\n\t                }\n\t\n\t                mainWindow.useDefaultWindowBehaviour = true;\n\t                mainWindow.webContents.send('contextMenuClosed');\n\t            }\n\t        }, {\n\t            label: 'Copy link location',\n\t            click: function click() {\n\t                if (targetHref) {\n\t                    _electron.clipboard.writeText(targetHref);\n\t                    return;\n\t                }\n\t\n\t                mainWindow.useDefaultWindowBehaviour = true;\n\t                mainWindow.webContents.send('contextMenuClosed');\n\t            }\n\t        }];\n\t\n\t        var contextMenu = _electron.Menu.buildFromTemplate(contextMenuTemplate);\n\t        contextMenu.popup(mainWindow);\n\t        mainWindow.contextMenuOpen = true;\n\t    });\n\t}\n\t\n\texports.default = initContextMenu;\n\n/***/ }),\n/* 39 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _fs = __webpack_require__(15);\n\t\n\tvar _fs2 = _interopRequireDefault(_fs);\n\t\n\tvar _path = __webpack_require__(14);\n\t\n\tvar _path2 = _interopRequireDefault(_path);\n\t\n\tvar _helpers = __webpack_require__(34);\n\t\n\tvar _helpers2 = _interopRequireDefault(_helpers);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar isOSX = _helpers2.default.isOSX,\n\t    isWindows = _helpers2.default.isWindows,\n\t    isLinux = _helpers2.default.isLinux;\n\t\n\t\n\tfunction inferFlash() {\n\t    if (isOSX()) {\n\t        return darwinMatch();\n\t    }\n\t\n\t    if (isWindows()) {\n\t        return windowsMatch();\n\t    }\n\t\n\t    if (isLinux()) {\n\t        return linuxMatch();\n\t    }\n\t\n\t    console.warn('Unable to determine OS to infer flash player');\n\t}\n\t\n\t/**\n\t * Synchronously find a file or directory\n\t * @param {RegExp} pattern regex\n\t * @param {string} base path\n\t * @param {boolean} [findDir] if true, search results will be limited to only directories\n\t * @returns {Array}\n\t */\n\tfunction findSync(pattern, base, findDir) {\n\t    var matches = [];\n\t\n\t    (function findSyncRecurse(base) {\n\t        var children = void 0;\n\t        try {\n\t            children = _fs2.default.readdirSync(base);\n\t        } catch (exception) {\n\t            if (exception.code === 'ENOENT') {\n\t                return;\n\t            }\n\t            throw exception;\n\t        }\n\t\n\t        children.forEach(function (child) {\n\t            var childPath = _path2.default.join(base, child);\n\t            var childIsDirectory = _fs2.default.lstatSync(childPath).isDirectory();\n\t            var patternMatches = pattern.test(childPath);\n\t\n\t            if (!patternMatches) {\n\t                if (!childIsDirectory) {\n\t                    return;\n\t                }\n\t                findSyncRecurse(childPath);\n\t                return;\n\t            }\n\t\n\t            if (!findDir) {\n\t                matches.push(childPath);\n\t                return;\n\t            }\n\t\n\t            if (childIsDirectory) {\n\t                matches.push(childPath);\n\t            }\n\t        });\n\t    })(base);\n\t    return matches;\n\t}\n\t\n\tfunction linuxMatch() {\n\t    return findSync(/libpepflashplayer\\.so/, '/opt/google/chrome')[0];\n\t}\n\t\n\tfunction windowsMatch() {\n\t    return findSync(/pepflashplayer\\.dll/, 'C:\\\\Program Files (x86)\\\\Google\\\\Chrome')[0];\n\t}\n\t\n\tfunction darwinMatch() {\n\t    return findSync(/PepperFlashPlayer.plugin/, '/Applications/Google Chrome.app/', true)[0];\n\t}\n\t\n\texports.default = inferFlash;\n\n/***/ }),\n/* 40 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tconst path = __webpack_require__(14);\n\tconst electron = __webpack_require__(17);\n\tconst unusedFilename = __webpack_require__(41);\n\tconst pupa = __webpack_require__(44);\n\t\n\tconst app = electron.app;\n\tconst shell = electron.shell;\n\t\n\tfunction registerListener(win, opts = {}, cb = () => {}) {\n\t\tconst listener = (e, item, webContents) => {\n\t\t\tconst totalBytes = item.getTotalBytes();\n\t\t\tconst dir = opts.directory || app.getPath('downloads');\n\t\t\tlet filePath;\n\t\t\tif (opts.filename) {\n\t\t\t\tfilePath = path.join(dir, opts.filename);\n\t\t\t} else {\n\t\t\t\tfilePath = unusedFilename.sync(path.join(dir, item.getFilename()));\n\t\t\t}\n\t\t\tconst errorMessage = opts.errorMessage || 'The download of {filename} was interrupted';\n\t\t\tconst errorTitle = opts.errorTitle || 'Download Error';\n\t\n\t\t\tif (!opts.saveAs) {\n\t\t\t\titem.setSavePath(filePath);\n\t\t\t}\n\t\n\t\t\t// TODO: use mime type checking for file extension when no extension can be inferred\n\t\t\t// item.getMimeType()\n\t\n\t\t\titem.on('updated', () => {\n\t\t\t\tconst ratio = item.getReceivedBytes() / totalBytes;\n\t\t\t\tif (!win.isDestroyed()) {\n\t\t\t\t\twin.setProgressBar(ratio);\n\t\t\t\t}\n\t\n\t\t\t\tif (typeof opts.onProgress === 'function') {\n\t\t\t\t\topts.onProgress(ratio);\n\t\t\t\t}\n\t\t\t});\n\t\n\t\t\titem.on('done', (e, state) => {\n\t\t\t\tif (!win.isDestroyed()) {\n\t\t\t\t\twin.setProgressBar(-1);\n\t\t\t\t}\n\t\n\t\t\t\tif (state === 'interrupted') {\n\t\t\t\t\tconst message = pupa(errorMessage, {filename: item.getFilename()});\n\t\t\t\t\telectron.dialog.showErrorBox(errorTitle, message);\n\t\t\t\t\tcb(new Error(message));\n\t\t\t\t} else if (state === 'completed') {\n\t\t\t\t\tif (process.platform === 'darwin') {\n\t\t\t\t\t\tapp.dock.downloadFinished(filePath);\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif (opts.openFolderWhenDone) {\n\t\t\t\t\t\tshell.showItemInFolder(filePath);\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif (opts.unregisterWhenDone) {\n\t\t\t\t\t\twebContents.session.removeListener('will-download', listener);\n\t\t\t\t\t}\n\t\n\t\t\t\t\tcb(null, item);\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\t\n\t\twin.webContents.session.on('will-download', listener);\n\t}\n\t\n\tmodule.exports = (opts = {}) => {\n\t\tapp.on('browser-window-created', (e, win) => {\n\t\t\tregisterListener(win, opts);\n\t\t});\n\t};\n\t\n\tmodule.exports.download = (win, url, opts) => new Promise((resolve, reject) => {\n\t\topts = Object.assign({}, opts, {unregisterWhenDone: true});\n\t\tregisterListener(win, opts, (err, item) => err ? reject(err) : resolve(item));\n\t\twin.webContents.downloadURL(url);\n\t});\n\n\n/***/ }),\n/* 41 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tconst pathExists = __webpack_require__(42);\n\tconst modifyFilename = __webpack_require__(43);\n\t\n\tconst incrementer = fp => {\n\t\tlet i = 0;\n\t\treturn () => modifyFilename(fp, (filename, ext) => `${filename} (${++i})${ext}`);\n\t};\n\t\n\tmodule.exports = fp => {\n\t\tconst getFp = incrementer(fp);\n\t\tconst find = newFp => pathExists(newFp).then(x => x ? find(getFp()) : newFp);\n\t\treturn find(fp);\n\t};\n\t\n\tmodule.exports.sync = fp => {\n\t\tconst getFp = incrementer(fp);\n\t\tconst find = newFp => pathExists.sync(newFp) ? find(getFp()) : newFp;\n\t\treturn find(fp);\n\t};\n\n\n/***/ }),\n/* 42 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tconst fs = __webpack_require__(15);\n\t\n\tmodule.exports = fp => new Promise(resolve => {\n\t\tfs.access(fp, err => {\n\t\t\tresolve(!err);\n\t\t});\n\t});\n\t\n\tmodule.exports.sync = fp => {\n\t\ttry {\n\t\t\tfs.accessSync(fp);\n\t\t\treturn true;\n\t\t} catch (err) {\n\t\t\treturn false;\n\t\t}\n\t};\n\n\n/***/ }),\n/* 43 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar path = __webpack_require__(14);\n\t\n\tmodule.exports = function modifyFilename(pth, modifier) {\n\t\tif (arguments.length !== 2) {\n\t\t\tthrow new Error('`path` and `modifier` required');\n\t\t}\n\t\n\t\tif (Array.isArray(pth)) {\n\t\t\treturn pth.map(function (el) {\n\t\t\t\treturn modifyFilename(el, modifier);\n\t\t\t});\n\t\t}\n\t\n\t\tvar ext = path.extname(pth);\n\t\treturn path.join(path.dirname(pth), modifier(path.basename(pth, ext), ext));\n\t};\n\n\n/***/ }),\n/* 44 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\tmodule.exports = (tpl, data) => {\n\t\tif (typeof tpl !== 'string') {\n\t\t\tthrow new TypeError(`Expected a string in the first argument, got ${typeof tpl}`);\n\t\t}\n\t\n\t\tif (typeof data !== 'object') {\n\t\t\tthrow new TypeError(`Expected an Object/Array in the second argument, got ${typeof data}`);\n\t\t}\n\t\n\t\tconst re = /{(.*?)}/g;\n\t\n\t\treturn tpl.replace(re, (_, key) => {\n\t\t\tlet ret = data;\n\t\n\t\t\tfor (const prop of key.split('.')) {\n\t\t\t\tret = ret ? ret[prop] : '';\n\t\t\t}\n\t\n\t\t\treturn ret || '';\n\t\t});\n\t};\n\n\n/***/ })\n/******/ ]);\n//# sourceMappingURL=main.js.map","/home/travis/build/npmtest/node-npmtest-nativefier/node_modules/nativefier/app/src/main.js":"import 'source-map-support/register';\nimport fs from 'fs';\nimport path from 'path';\nimport {app, crashReporter} from 'electron';\nimport createLoginWindow from './components/login/loginWindow';\nimport createMainWindow from './components/mainWindow/mainWindow';\nimport helpers from './helpers/helpers';\nimport inferFlash from './helpers/inferFlash';\nimport electronDownload from 'electron-dl';\n\nconst {isOSX} = helpers;\n\nelectronDownload();\n\nconst APP_ARGS_FILE_PATH = path.join(__dirname, '..', 'nativefier.json');\nconst appArgs = JSON.parse(fs.readFileSync(APP_ARGS_FILE_PATH, 'utf8'));\n\nlet mainWindow;\n\nif (typeof appArgs.flashPluginDir === 'string') {\n    app.commandLine.appendSwitch('ppapi-flash-path', appArgs.flashPluginDir);\n} else if (appArgs.flashPluginDir) {\n    const flashPath = inferFlash();\n    app.commandLine.appendSwitch('ppapi-flash-path', flashPath);\n}\n\nif (appArgs.ignoreCertificate) {\n    app.commandLine.appendSwitch('ignore-certificate-errors');\n}\n\n// do nothing for setDockBadge if not OSX\nlet setDockBadge = () => {};\n\nif (isOSX()) {\n    setDockBadge = app.dock.setBadge;\n}\n\napp.on('window-all-closed', () => {\n    if (!isOSX() || appArgs.fastQuit) {\n        app.quit();\n    }\n});\n\napp.on('activate', (event, hasVisibleWindows) => {\n    if (isOSX()) {\n        // this is called when the dock is clicked\n        if (!hasVisibleWindows) {\n            mainWindow.show();\n        }\n    }\n});\n\napp.on('before-quit', () => {\n    // not fired when the close button on the window is clicked\n    if (isOSX()) {\n        // need to force a quit as a workaround here to simulate the osx app hiding behaviour\n        // Somehow sokution at https://github.com/atom/electron/issues/444#issuecomment-76492576 does not work,\n        // e.prevent default appears to persist\n\n        // might cause issues in the future as before-quit and will-quit events are not called\n        app.exit(0);\n    }\n});\n\nif (appArgs.crashReporter) {\n    app.on('will-finish-launching', () => {\n        crashReporter.start({\n            productName: appArgs.name,\n            submitURL: appArgs.crashReporter,\n            autoSubmit: true\n        });\n    });\n}\n\napp.on('ready', () => {\n    mainWindow = createMainWindow(appArgs, app.quit, setDockBadge);\n});\n\napp.on('login', (event, webContents, request, authInfo, callback) => {\n    // for http authentication\n    event.preventDefault();\n    createLoginWindow(callback);\n});\n\nif (appArgs.singleInstance) {\n    const shouldQuit = app.makeSingleInstance(() => {\n        // Someone tried to run a second instance, we should focus our window.\n        if (mainWindow) {\n            if (mainWindow.isMinimized()) {\n                mainWindow.restore();\n            }\n            mainWindow.focus();\n\n        }\n    });\n\n    if (shouldQuit) {\n        app.quit();\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-nativefier/node_modules/nativefier/lib/helpers/convertToIcns.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _shelljs = require('shelljs');\n\nvar _shelljs2 = _interopRequireDefault(_shelljs);\n\nvar _path = require('path');\n\nvar _path2 = _interopRequireDefault(_path);\n\nvar _tmp = require('tmp');\n\nvar _tmp2 = _interopRequireDefault(_tmp);\n\nvar _helpers = require('./helpers');\n\nvar _helpers2 = _interopRequireDefault(_helpers);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar isOSX = _helpers2.default.isOSX;\n_tmp2.default.setGracefulCleanup();\n\nvar PNG_TO_ICNS_BIN_PATH = _path2.default.join(__dirname, '../..', 'bin/convertToIcns');\n\n/**\n * @callback pngToIcnsCallback\n * @param error\n * @param {string} icnsDest If error, will return the original png src\n */\n\n/**\n *\n * @param {string} pngSrc\n * @param {string} icnsDest\n * @param {pngToIcnsCallback} callback\n */\nfunction convertToIcns(pngSrc, icnsDest, callback) {\n    if (!isOSX()) {\n        callback('OSX is required to convert .png to .icns icon', pngSrc);\n        return;\n    }\n\n    _shelljs2.default.exec(PNG_TO_ICNS_BIN_PATH + ' ' + pngSrc + ' ' + icnsDest, { silent: true }, function (exitCode, stdOut, stdError) {\n        if (stdOut.includes('icon.iconset:error') || exitCode) {\n            if (exitCode) {\n                callback({\n                    stdOut: stdOut,\n                    stdError: stdError\n                }, pngSrc);\n                return;\n            }\n\n            callback(stdOut, pngSrc);\n            return;\n        }\n\n        callback(null, icnsDest);\n    });\n}\n\n/**\n * Converts the png to a temporary directory which will be cleaned up on process exit\n * @param {string} pngSrc\n * @param {pngToIcnsCallback} callback\n */\nfunction convertToIcnsTmp(pngSrc, callback) {\n    var tempIconDirObj = _tmp2.default.dirSync({ unsafeCleanup: true });\n    var tempIconDirPath = tempIconDirObj.name;\n    convertToIcns(pngSrc, tempIconDirPath + '/icon.icns', callback);\n}\n\nexports.default = convertToIcnsTmp;\n//# sourceMappingURL=convertToIcns.js.map\n","/home/travis/build/npmtest/node-npmtest-nativefier/node_modules/nativefier/lib/helpers/helpers.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _os = require('os');\n\nvar _os2 = _interopRequireDefault(_os);\n\nvar _axios = require('axios');\n\nvar _axios2 = _interopRequireDefault(_axios);\n\nvar _hasbin = require('hasbin');\n\nvar _hasbin2 = _interopRequireDefault(_hasbin);\n\nvar _path = require('path');\n\nvar _path2 = _interopRequireDefault(_path);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction isOSX() {\n    return _os2.default.platform() === 'darwin';\n}\n\nfunction isWindows() {\n    return _os2.default.platform() === 'win32';\n}\n\nfunction downloadFile(fileUrl) {\n    return _axios2.default.get(fileUrl, {\n        responseType: 'arraybuffer'\n    }).then(function (response) {\n        if (!response.data) {\n            return null;\n        }\n        return {\n            data: response.data,\n            ext: _path2.default.extname(fileUrl)\n        };\n    });\n}\n\nfunction allowedIconFormats(platform) {\n    var hasIdentify = _hasbin2.default.sync('identify');\n    var hasConvert = _hasbin2.default.sync('convert');\n    var hasIconUtil = _hasbin2.default.sync('iconutil');\n\n    var pngToIcns = hasConvert && hasIconUtil;\n    var pngToIco = hasConvert;\n    var icoToIcns = pngToIcns && hasIdentify;\n    var icoToPng = hasConvert;\n\n    // todo scripts for the following\n    var icnsToPng = false;\n    var icnsToIco = false;\n\n    var formats = [];\n\n    // todo shell scripting is not supported on windows, temporary override\n    if (isWindows()) {\n        switch (platform) {\n            case 'darwin':\n                formats.push('.icns');\n                break;\n            case 'linux':\n                formats.push('.png');\n                break;\n            case 'win32':\n                formats.push('.ico');\n                break;\n            default:\n                throw 'function allowedIconFormats error: Unknown platform ' + platform;\n        }\n        return formats;\n    }\n\n    switch (platform) {\n        case 'darwin':\n            formats.push('.icns');\n            if (pngToIcns) {\n                formats.push('.png');\n            }\n            if (icoToIcns) {\n                formats.push('.ico');\n            }\n            break;\n        case 'linux':\n            formats.push('.png');\n            if (icoToPng) {\n                formats.push('.ico');\n            }\n            if (icnsToPng) {\n                formats.push('.icns');\n            }\n            break;\n        case 'win32':\n            formats.push('.ico');\n            if (pngToIco) {\n                formats.push('.png');\n            }\n            if (icnsToIco) {\n                formats.push('.icns');\n            }\n            break;\n        default:\n            throw 'function allowedIconFormats error: Unknown platform ' + platform;\n    }\n    return formats;\n}\n\nexports.default = {\n    isOSX: isOSX,\n    isWindows: isWindows,\n    downloadFile: downloadFile,\n    allowedIconFormats: allowedIconFormats\n};\n//# sourceMappingURL=helpers.js.map\n","/home/travis/build/npmtest/node-npmtest-nativefier/node_modules/nativefier/lib/helpers/dishonestProgress.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _progress = require('progress');\n\nvar _progress2 = _interopRequireDefault(_progress);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar DishonestProgress = function () {\n    function DishonestProgress(total) {\n        _classCallCheck(this, DishonestProgress);\n\n        this.tickParts = total * 10;\n\n        this.bar = new _progress2.default('  :task [:bar] :percent', {\n            complete: '=',\n            incomplete: ' ',\n            total: total * this.tickParts,\n            width: 50,\n            clear: true\n        });\n\n        this.tickingPrevious = {\n            message: '',\n            remainder: 0,\n            interval: null\n        };\n    }\n\n    _createClass(DishonestProgress, [{\n        key: 'tick',\n        value: function tick(message) {\n            var _this = this;\n\n            var _tickingPrevious = this.tickingPrevious,\n                prevRemainder = _tickingPrevious.remainder,\n                prevMessage = _tickingPrevious.message,\n                prevInterval = _tickingPrevious.interval;\n\n\n            if (prevRemainder) {\n                this.bar.tick(prevRemainder, {\n                    task: prevMessage\n                });\n                clearInterval(prevInterval);\n            }\n\n            var realRemainder = this.bar.total - this.bar.curr;\n            if (realRemainder === this.tickParts) {\n                this.bar.tick(this.tickParts, {\n                    task: message\n                });\n                return;\n            }\n\n            this.bar.tick({\n                task: message\n            });\n\n            this.tickingPrevious = {\n                message: message,\n                remainder: this.tickParts,\n                interval: null\n            };\n\n            this.tickingPrevious.remainder -= 1;\n\n            this.tickingPrevious.interval = setInterval(function () {\n                if (_this.tickingPrevious.remainder === 1) {\n                    clearInterval(_this.tickingPrevious.interval);\n                    return;\n                }\n\n                _this.bar.tick({\n                    task: message\n                });\n                _this.tickingPrevious.remainder -= 1;\n            }, 200);\n        }\n    }]);\n\n    return DishonestProgress;\n}();\n\nexports.default = DishonestProgress;\n//# sourceMappingURL=dishonestProgress.js.map\n","/home/travis/build/npmtest/node-npmtest-nativefier/node_modules/nativefier/lib/helpers/iconShellHelpers.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _shelljs = require('shelljs');\n\nvar _shelljs2 = _interopRequireDefault(_shelljs);\n\nvar _path = require('path');\n\nvar _path2 = _interopRequireDefault(_path);\n\nvar _tmp = require('tmp');\n\nvar _tmp2 = _interopRequireDefault(_tmp);\n\nvar _helpers = require('./helpers');\n\nvar _helpers2 = _interopRequireDefault(_helpers);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar isWindows = _helpers2.default.isWindows,\n    isOSX = _helpers2.default.isOSX;\n\n\n_tmp2.default.setGracefulCleanup();\n\nvar SCRIPT_PATHS = {\n    singleIco: _path2.default.join(__dirname, '../..', 'bin/singleIco'),\n    convertToPng: _path2.default.join(__dirname, '../..', 'bin/convertToPng'),\n    convertToIco: _path2.default.join(__dirname, '../..', 'bin/convertToIco'),\n    convertToIcns: _path2.default.join(__dirname, '../..', 'bin/convertToIcns')\n};\n\n/**\n * Executes a shell script with the form \"./pathToScript param1 param2\"\n * @param {string} shellScriptPath\n * @param {string} icoSrc input .ico\n * @param {string} dest has to be a .ico path\n */\nfunction iconShellHelper(shellScriptPath, icoSrc, dest) {\n    return new Promise(function (resolve, reject) {\n        if (isWindows()) {\n            reject('OSX or Linux is required');\n            return;\n        }\n\n        _shelljs2.default.exec(shellScriptPath + ' ' + icoSrc + ' ' + dest, { silent: true }, function (exitCode, stdOut, stdError) {\n            if (exitCode) {\n                reject({\n                    stdOut: stdOut,\n                    stdError: stdError\n                });\n                return;\n            }\n\n            resolve(dest);\n        });\n    });\n}\n\nfunction getTmpDirPath() {\n    var tempIconDirObj = _tmp2.default.dirSync({ unsafeCleanup: true });\n    return tempIconDirObj.name;\n}\n\n/**\n * Converts the ico to a temporary directory which will be cleaned up on process exit\n * @param {string} icoSrc path to a .ico file\n * @return {Promise}\n */\n\nfunction singleIco(icoSrc) {\n    return iconShellHelper(SCRIPT_PATHS.singleIco, icoSrc, getTmpDirPath() + '/icon.ico');\n}\n\nfunction convertToPng(icoSrc) {\n    return iconShellHelper(SCRIPT_PATHS.convertToPng, icoSrc, getTmpDirPath() + '/icon.png');\n}\n\nfunction convertToIco(icoSrc) {\n    return iconShellHelper(SCRIPT_PATHS.convertToIco, icoSrc, getTmpDirPath() + '/icon.ico');\n}\n\nfunction convertToIcns(icoSrc) {\n    if (!isOSX()) {\n        return new Promise(function (resolve, reject) {\n            return reject('OSX is required to convert to a .icns icon');\n        });\n    }\n    return iconShellHelper(SCRIPT_PATHS.convertToIcns, icoSrc, getTmpDirPath() + '/icon.icns');\n}\n\nexports.default = {\n    singleIco: singleIco,\n    convertToPng: convertToPng,\n    convertToIco: convertToIco,\n    convertToIcns: convertToIcns\n};\n//# sourceMappingURL=iconShellHelpers.js.map\n","/home/travis/build/npmtest/node-npmtest-nativefier/node_modules/nativefier/lib/helpers/packagerConsole.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar PackagerConsole = function () {\n    function PackagerConsole() {\n        _classCallCheck(this, PackagerConsole);\n\n        this.logs = [];\n    }\n\n    _createClass(PackagerConsole, [{\n        key: '_log',\n        value: function _log() {\n            var _logs;\n\n            (_logs = this.logs).push.apply(_logs, arguments);\n        }\n    }, {\n        key: 'override',\n        value: function override() {\n            this.consoleError = console.error;\n\n            // need to bind because somehow when _log() is called this refers to console\n            console.error = this._log.bind(this);\n        }\n    }, {\n        key: 'restore',\n        value: function restore() {\n            console.error = this.consoleError;\n        }\n    }, {\n        key: 'playback',\n        value: function playback() {\n            console.log(this.logs.join(' '));\n        }\n    }]);\n\n    return PackagerConsole;\n}();\n\nexports.default = PackagerConsole;\n//# sourceMappingURL=packagerConsole.js.map\n","/home/travis/build/npmtest/node-npmtest-nativefier/node_modules/nativefier/lib/infer/inferIcon.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _pageIcon = require('page-icon');\n\nvar _pageIcon2 = _interopRequireDefault(_pageIcon);\n\nvar _path = require('path');\n\nvar _path2 = _interopRequireDefault(_path);\n\nvar _fs = require('fs');\n\nvar _fs2 = _interopRequireDefault(_fs);\n\nvar _tmp = require('tmp');\n\nvar _tmp2 = _interopRequireDefault(_tmp);\n\nvar _gitcloud = require('gitcloud');\n\nvar _gitcloud2 = _interopRequireDefault(_gitcloud);\n\nvar _helpers = require('./../helpers/helpers');\n\nvar _helpers2 = _interopRequireDefault(_helpers);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar downloadFile = _helpers2.default.downloadFile,\n    allowedIconFormats = _helpers2.default.allowedIconFormats;\n\n_tmp2.default.setGracefulCleanup();\n\nvar GITCLOUD_SPACE_DELIMITER = '-';\n\nfunction inferIconFromStore(targetUrl, platform) {\n    var allowedFormats = allowedIconFormats(platform);\n\n    return (0, _gitcloud2.default)('http://jiahaog.com/nativefier-icons/').then(function (fileIndex) {\n        var iconWithScores = mapIconWithMatchScore(fileIndex, targetUrl);\n        var maxScore = getMaxMatchScore(iconWithScores);\n\n        if (maxScore === 0) {\n            return null;\n        }\n\n        var matchingIcons = getMatchingIcons(iconWithScores, maxScore);\n\n        var matchingUrl = void 0;\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n            for (var _iterator = allowedFormats[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                var format = _step.value;\n                var _iteratorNormalCompletion2 = true;\n                var _didIteratorError2 = false;\n                var _iteratorError2 = undefined;\n\n                try {\n                    for (var _iterator2 = matchingIcons[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                        var icon = _step2.value;\n\n                        if (icon.ext !== format) {\n                            continue;\n                        }\n                        matchingUrl = icon.url;\n                    }\n                } catch (err) {\n                    _didIteratorError2 = true;\n                    _iteratorError2 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                            _iterator2.return();\n                        }\n                    } finally {\n                        if (_didIteratorError2) {\n                            throw _iteratorError2;\n                        }\n                    }\n                }\n            }\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally {\n            try {\n                if (!_iteratorNormalCompletion && _iterator.return) {\n                    _iterator.return();\n                }\n            } finally {\n                if (_didIteratorError) {\n                    throw _iteratorError;\n                }\n            }\n        }\n\n        if (!matchingUrl) {\n            return null;\n        }\n        return downloadFile(matchingUrl);\n    });\n}\n\nfunction mapIconWithMatchScore(fileIndex, targetUrl) {\n    var normalisedTargetUrl = targetUrl.toLowerCase();\n    return fileIndex.map(function (item) {\n        var itemWords = item.name.split(GITCLOUD_SPACE_DELIMITER);\n        var score = itemWords.reduce(function (currentScore, word) {\n            if (normalisedTargetUrl.includes(word)) {\n                return currentScore + 1;\n            }\n            return currentScore;\n        }, 0);\n\n        return Object.assign({}, item, { score: score });\n    });\n}\n\nfunction getMaxMatchScore(iconWithScores) {\n    return iconWithScores.reduce(function (maxScore, currentIcon) {\n        var currentScore = currentIcon.score;\n        if (currentScore > maxScore) {\n            return currentScore;\n        }\n        return maxScore;\n    }, 0);\n}\n\n/**\n * also maps ext to icon object\n */\nfunction getMatchingIcons(iconWithScores, maxScore) {\n    return iconWithScores.filter(function (item) {\n        return item.score === maxScore;\n    }).map(function (item) {\n        return Object.assign({}, item, { ext: _path2.default.extname(item.url) });\n    });\n}\n\nfunction writeFilePromise(outPath, data) {\n    return new Promise(function (resolve, reject) {\n        _fs2.default.writeFile(outPath, data, function (error) {\n            if (error) {\n                reject(error);\n                return;\n            }\n            resolve(outPath);\n        });\n    });\n}\n\nfunction inferFromPage(targetUrl, platform, outDir) {\n    var preferredExt = '.png';\n    if (platform === 'win32') {\n        preferredExt = '.ico';\n    }\n\n    // todo might want to pass list of preferences instead\n    return (0, _pageIcon2.default)(targetUrl, { ext: preferredExt }).then(function (icon) {\n        if (!icon) {\n            return null;\n        }\n\n        var outfilePath = _path2.default.join(outDir, '/icon' + icon.ext);\n        return writeFilePromise(outfilePath, icon.data);\n    });\n}\n/**\n *\n * @param {string} targetUrl\n * @param {string} platform\n * @param {string} outDir\n */\nfunction inferIconFromUrlToPath(targetUrl, platform, outDir) {\n\n    return inferIconFromStore(targetUrl, platform).then(function (icon) {\n        if (!icon) {\n            return inferFromPage(targetUrl, platform, outDir);\n        }\n\n        var outfilePath = _path2.default.join(outDir, '/icon' + icon.ext);\n        return writeFilePromise(outfilePath, icon.data);\n    });\n}\n\n/**\n * @param {string} targetUrl\n * @param {string} platform\n */\nfunction inferIcon(targetUrl, platform) {\n    var tmpObj = _tmp2.default.dirSync({ unsafeCleanup: true });\n    var tmpPath = tmpObj.name;\n    return inferIconFromUrlToPath(targetUrl, platform, tmpPath);\n}\n\nexports.default = inferIcon;\n//# sourceMappingURL=inferIcon.js.map\n","/home/travis/build/npmtest/node-npmtest-nativefier/node_modules/nativefier/lib/infer/inferOs.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _os = require('os');\n\nvar _os2 = _interopRequireDefault(_os);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction inferPlatform() {\n    var platform = _os2.default.platform();\n    if (platform === 'darwin' || platform === 'win32' || platform === 'linux') {\n        return platform;\n    }\n\n    throw 'Untested platform ' + platform + ' detected';\n}\n\nfunction inferArch() {\n    var arch = _os2.default.arch();\n    if (arch !== 'ia32' && arch !== 'x64') {\n        throw 'Incompatible architecture ' + arch + ' detected';\n    }\n    return arch;\n}\n\nexports.default = {\n    inferPlatform: inferPlatform,\n    inferArch: inferArch\n};\n//# sourceMappingURL=inferOs.js.map\n","/home/travis/build/npmtest/node-npmtest-nativefier/node_modules/nativefier/lib/infer/inferTitle.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _request = require('request');\n\nvar _request2 = _interopRequireDefault(_request);\n\nvar _cheerio = require('cheerio');\n\nvar _cheerio2 = _interopRequireDefault(_cheerio);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction inferTitle(url, callback) {\n    var options = {\n        url: url,\n        headers: {\n            // fake a user agent because pages like http://messenger.com will throw 404 error\n            'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2227.1 Safari/537.36'\n        }\n    };\n\n    (0, _request2.default)(options, function (error, response, body) {\n        if (error || response.statusCode !== 200) {\n            callback('Request Error: ' + error + ', Status Code ' + (response ? response.statusCode : 'No Response'));\n            return;\n        }\n\n        var $ = _cheerio2.default.load(body);\n        var pageTitle = $('title').first().text().replace(/\\//g, '');\n        callback(null, pageTitle);\n    });\n}\n\nexports.default = inferTitle;\n//# sourceMappingURL=inferTitle.js.map\n","/home/travis/build/npmtest/node-npmtest-nativefier/node_modules/nativefier/lib/infer/inferUserAgent.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.getUserAgentString = getUserAgentString;\n\nvar _axios = require('axios');\n\nvar _axios2 = _interopRequireDefault(_axios);\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _loglevel = require('loglevel');\n\nvar _loglevel2 = _interopRequireDefault(_loglevel);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar ELECTRON_VERSIONS_URL = 'https://atom.io/download/atom-shell/index.json';\nvar DEFAULT_CHROME_VERSION = '56.0.2924.87';\n\nfunction getChromeVersionForElectronVersion(electronVersion) {\n    var url = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ELECTRON_VERSIONS_URL;\n\n    return _axios2.default.get(url, { timeout: 5000 }).then(function (response) {\n        if (response.status !== 200) {\n            throw 'Bad request: Status code ' + response.status;\n        }\n\n        var data = response.data;\n        var electronVersionToChromeVersion = _lodash2.default.zipObject(data.map(function (d) {\n            return d.version;\n        }), data.map(function (d) {\n            return d.chrome;\n        }));\n\n        if (!(electronVersion in electronVersionToChromeVersion)) {\n            throw 'Electron version \\'' + electronVersion + '\\' not found in retrieved version list!';\n        }\n\n        return electronVersionToChromeVersion[electronVersion];\n    });\n}\n\nfunction getUserAgentString(chromeVersion, platform) {\n    var userAgent = void 0;\n    switch (platform) {\n        case 'darwin':\n            userAgent = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/' + chromeVersion + ' Safari/537.36';\n            break;\n        case 'win32':\n            userAgent = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/' + chromeVersion + ' Safari/537.36';\n            break;\n        case 'linux':\n            userAgent = 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/' + chromeVersion + ' Safari/537.36';\n            break;\n        default:\n            throw 'Error invalid platform specified to getUserAgentString()';\n    }\n    return userAgent;\n}\n\nfunction inferUserAgent(electronVersion, platform) {\n    var url = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ELECTRON_VERSIONS_URL;\n\n    return getChromeVersionForElectronVersion(electronVersion, url).then(function (chromeVersion) {\n        return getUserAgentString(chromeVersion, platform);\n    }).catch(function () {\n        _loglevel2.default.warn('Unable to infer chrome version for user agent, using ' + DEFAULT_CHROME_VERSION);\n        return getUserAgentString(DEFAULT_CHROME_VERSION, platform);\n    });\n}\n\nexports.default = inferUserAgent;\n//# sourceMappingURL=inferUserAgent.js.map\n","/home/travis/build/npmtest/node-npmtest-nativefier/node_modules/nativefier/lib/options/normalizeUrl.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _url = require('url');\n\nvar _url2 = _interopRequireDefault(_url);\n\nvar _validator = require('validator');\n\nvar _validator2 = _interopRequireDefault(_validator);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction normalizeUrl(testUrl) {\n    // add protocol if protocol not found\n    var normalized = testUrl;\n    var parsed = _url2.default.parse(normalized);\n    if (!parsed.protocol) {\n        normalized = 'http://' + normalized;\n    }\n\n    var validatorOptions = {\n        require_protocol: true,\n        require_tld: false,\n        allow_trailing_dot: true // mDNS addresses, https://github.com/jiahaog/nativefier/issues/308\n    };\n    if (!_validator2.default.isURL(normalized, validatorOptions)) {\n        throw 'Your Url: \"' + normalized + '\" is invalid!';\n    }\n    return normalized;\n}\n\nexports.default = normalizeUrl;\n//# sourceMappingURL=normalizeUrl.js.map\n","/home/travis/build/npmtest/node-npmtest-nativefier/node_modules/nativefier/lib/options/optionsMain.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _path = require('path');\n\nvar _path2 = _interopRequireDefault(_path);\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _async = require('async');\n\nvar _async2 = _interopRequireDefault(_async);\n\nvar _loglevel = require('loglevel');\n\nvar _loglevel2 = _interopRequireDefault(_loglevel);\n\nvar _sanitizeFilename = require('sanitize-filename');\n\nvar _sanitizeFilename2 = _interopRequireDefault(_sanitizeFilename);\n\nvar _inferIcon = require('./../infer/inferIcon');\n\nvar _inferIcon2 = _interopRequireDefault(_inferIcon);\n\nvar _inferTitle = require('./../infer/inferTitle');\n\nvar _inferTitle2 = _interopRequireDefault(_inferTitle);\n\nvar _inferOs = require('./../infer/inferOs');\n\nvar _inferOs2 = _interopRequireDefault(_inferOs);\n\nvar _inferUserAgent = require('./../infer/inferUserAgent');\n\nvar _inferUserAgent2 = _interopRequireDefault(_inferUserAgent);\n\nvar _normalizeUrl = require('./normalizeUrl');\n\nvar _normalizeUrl2 = _interopRequireDefault(_normalizeUrl);\n\nvar _package = require('./../../package.json');\n\nvar _package2 = _interopRequireDefault(_package);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar inferPlatform = _inferOs2.default.inferPlatform,\n    inferArch = _inferOs2.default.inferArch;\n\n\nvar PLACEHOLDER_APP_DIR = _path2.default.join(__dirname, '../../', 'app');\nvar ELECTRON_VERSION = '1.6.6';\n\nvar DEFAULT_APP_NAME = 'APP';\n\n/**\n * @callback optionsCallback\n * @param error\n * @param options augmented options\n */\n\n/**\n * Extracts only desired keys from inpOptions and augments it with defaults\n * @param inpOptions\n * @param {optionsCallback} callback\n */\nfunction optionsFactory(inpOptions, callback) {\n\n    var options = {\n        dir: PLACEHOLDER_APP_DIR,\n        name: inpOptions.name,\n        targetUrl: (0, _normalizeUrl2.default)(inpOptions.targetUrl),\n        platform: inpOptions.platform || inferPlatform(),\n        arch: inpOptions.arch || inferArch(),\n        electronVersion: inpOptions.electronVersion || ELECTRON_VERSION,\n        nativefierVersion: _package2.default.version,\n        out: inpOptions.out || process.cwd(),\n        overwrite: inpOptions.overwrite,\n        asar: inpOptions.conceal || false,\n        icon: inpOptions.icon,\n        counter: inpOptions.counter || false,\n        width: inpOptions.width || 1280,\n        height: inpOptions.height || 800,\n        minWidth: inpOptions.minWidth,\n        minHeight: inpOptions.minHeight,\n        maxWidth: inpOptions.maxWidth,\n        maxHeight: inpOptions.maxHeight,\n        showMenuBar: inpOptions.showMenuBar || false,\n        fastQuit: inpOptions.fastQuit || false,\n        userAgent: inpOptions.userAgent,\n        ignoreCertificate: inpOptions.ignoreCertificate || false,\n        insecure: inpOptions.insecure || false,\n        flashPluginDir: inpOptions.flashPath || inpOptions.flash || null,\n        inject: inpOptions.inject || null,\n        ignore: 'src',\n        fullScreen: inpOptions.fullScreen || false,\n        maximize: inpOptions.maximize || false,\n        hideWindowFrame: inpOptions.hideWindowFrame,\n        verbose: inpOptions.verbose,\n        disableContextMenu: inpOptions.disableContextMenu,\n        disableDevTools: inpOptions.disableDevTools,\n        crashReporter: inpOptions.crashReporter,\n        // workaround for electron-packager#375\n        tmpdir: false,\n        zoom: inpOptions.zoom || 1.0,\n        internalUrls: inpOptions.internalUrls || null,\n        singleInstance: inpOptions.singleInstance || false\n    };\n\n    if (options.verbose) {\n        _loglevel2.default.setLevel('trace');\n    } else {\n        _loglevel2.default.setLevel('error');\n    }\n\n    if (options.flashPluginDir) {\n        options.insecure = true;\n    }\n\n    if (inpOptions.honest) {\n        options.userAgent = null;\n    }\n\n    if (options.platform.toLowerCase() === 'windows') {\n        options.platform = 'win32';\n    }\n\n    if (options.platform.toLowerCase() === 'osx' || options.platform.toLowerCase() === 'mac') {\n        options.platform = 'darwin';\n    }\n\n    if (options.width > options.maxWidth) {\n        options.width = options.maxWidth;\n    }\n\n    if (options.height > options.maxHeight) {\n        options.height = options.maxHeight;\n    }\n\n    _async2.default.waterfall([function (callback) {\n        if (options.userAgent) {\n            callback();\n            return;\n        }\n        (0, _inferUserAgent2.default)(options.electronVersion, options.platform).then(function (userAgent) {\n            options.userAgent = userAgent;\n            callback();\n        }).catch(callback);\n    }, function (callback) {\n        if (options.icon) {\n            callback();\n            return;\n        }\n        (0, _inferIcon2.default)(options.targetUrl, options.platform).then(function (pngPath) {\n            options.icon = pngPath;\n            callback();\n        }).catch(function (error) {\n            _loglevel2.default.warn('Cannot automatically retrieve the app icon:', error);\n            callback();\n        });\n    }, function (callback) {\n        // length also checks if its the commanderJS function or a string\n        if (options.name && options.name.length > 0) {\n            callback();\n            return;\n        }\n\n        (0, _inferTitle2.default)(options.targetUrl, function (error, pageTitle) {\n            if (error) {\n                _loglevel2.default.warn('Unable to automatically determine app name, falling back to \\'' + DEFAULT_APP_NAME + '\\'');\n                options.name = DEFAULT_APP_NAME;\n            } else {\n                options.name = pageTitle.trim();\n            }\n            if (options.platform === 'linux') {\n                // spaces will cause problems with Ubuntu when pinned to the dock\n                options.name = _lodash2.default.kebabCase(options.name);\n            }\n            callback();\n        });\n    }], function (error) {\n        callback(error, sanitizeOptions(options));\n    });\n}\n\nfunction sanitizeFilename(str) {\n    var cleaned = (0, _sanitizeFilename2.default)(str);\n    // remove all non ascii or use default app name\n    return cleaned.replace(/[^\\x00-\\x7F]/g, '') || DEFAULT_APP_NAME;\n}\n\nfunction sanitizeOptions(options) {\n    options.name = sanitizeFilename(options.name);\n    return options;\n}\n\nexports.default = optionsFactory;\n//# sourceMappingURL=optionsMain.js.map\n","/home/travis/build/npmtest/node-npmtest-nativefier/node_modules/nativefier/app/lib/static/preload.js":"'use strict';\n\nvar _electron = require('electron');\n\nvar _path = require('path');\n\nvar _path2 = _interopRequireDefault(_path);\n\nvar _fs = require('fs');\n\nvar _fs2 = _interopRequireDefault(_fs);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar INJECT_JS_PATH = _path2.default.join(__dirname, '../../', 'inject/inject.js'); /**\n                                                                                    Preload file that will be executed in the renderer process\n                                                                                    */\n\n\nsetNotificationCallback(function (title, opt) {\n    _electron.ipcRenderer.send('notification', title, opt);\n});\n\ndocument.addEventListener('DOMContentLoaded', function () {\n    // do things\n\n    window.addEventListener('contextmenu', function (event) {\n        event.preventDefault();\n        var targetElement = event.srcElement;\n\n        // the clicked element is the deepest in the DOM, and may not be the <a> bearing the href\n        // for example, <a href=\"...\"><span>Google</span></a>\n        while (!targetElement.href && targetElement.parentElement) {\n            targetElement = targetElement.parentElement;\n        }\n        var targetHref = targetElement.href;\n\n        if (!targetHref) {\n            _electron.ipcRenderer.once('contextMenuClosed', function () {\n                clickSelector(event.target);\n                _electron.ipcRenderer.send('cancelNewWindowOverride');\n            });\n        }\n\n        _electron.ipcRenderer.send('contextMenuOpened', targetHref);\n    }, false);\n\n    injectScripts();\n});\n\n_electron.ipcRenderer.on('params', function (event, message) {\n    var appArgs = JSON.parse(message);\n    console.log('nativefier.json', appArgs);\n});\n\n_electron.ipcRenderer.on('debug', function (event, message) {\n    console.log('debug:', message);\n});\n\n_electron.ipcRenderer.on('change-zoom', function (event, message) {\n    _electron.webFrame.setZoomFactor(message);\n});\n\n/**\n * Patches window.Notification to set a callback on a new Notification\n * @param callback\n */\nfunction setNotificationCallback(callback) {\n\n    var OldNotify = window.Notification;\n    var newNotify = function newNotify(title, opt) {\n        callback(title, opt);\n        return new OldNotify(title, opt);\n    };\n    newNotify.requestPermission = OldNotify.requestPermission.bind(OldNotify);\n    Object.defineProperty(newNotify, 'permission', {\n        get: function get() {\n            return OldNotify.permission;\n        }\n    });\n\n    window.Notification = newNotify;\n}\n\nfunction clickSelector(element) {\n    var mouseEvent = new MouseEvent('click');\n    element.dispatchEvent(mouseEvent);\n}\n\nfunction injectScripts() {\n    var needToInject = _fs2.default.existsSync(INJECT_JS_PATH);\n    if (!needToInject) {\n        return;\n    }\n    require(INJECT_JS_PATH);\n}\n//# sourceMappingURL=preload.js.map\n","/home/travis/build/npmtest/node-npmtest-nativefier/node_modules/nativefier/app/src/helpers/inferFlash.js":"import fs from 'fs';\nimport path from 'path';\nimport helpers from './helpers';\n\nconst {isOSX, isWindows, isLinux} = helpers;\n\nfunction inferFlash() {\n    if (isOSX()) {\n        return darwinMatch();\n    }\n\n    if (isWindows()) {\n        return windowsMatch();\n    }\n\n    if (isLinux()) {\n        return linuxMatch();\n    }\n\n    console.warn('Unable to determine OS to infer flash player');\n}\n\n/**\n * Synchronously find a file or directory\n * @param {RegExp} pattern regex\n * @param {string} base path\n * @param {boolean} [findDir] if true, search results will be limited to only directories\n * @returns {Array}\n */\nfunction findSync(pattern, base, findDir) {\n    const matches = [];\n\n    (function findSyncRecurse(base) {\n        let children;\n        try {\n            children = fs.readdirSync(base);\n        } catch (exception) {\n            if (exception.code === 'ENOENT') {\n                return;\n            }\n            throw exception;\n        }\n\n        children.forEach(child => {\n            const childPath = path.join(base, child);\n            const childIsDirectory = fs.lstatSync(childPath).isDirectory();\n            const patternMatches = pattern.test(childPath);\n\n            if (!patternMatches) {\n                if (!childIsDirectory) {\n                    return;\n                }\n                findSyncRecurse(childPath);\n                return;\n            }\n\n            if (!findDir) {\n                matches.push(childPath);\n                return;\n            }\n\n            if (childIsDirectory) {\n                matches.push(childPath);\n            }\n        });\n    })(base);\n    return matches;\n}\n\nfunction linuxMatch() {\n    return findSync(/libpepflashplayer\\.so/, '/opt/google/chrome')[0];\n}\n\nfunction windowsMatch() {\n    return findSync(/pepflashplayer\\.dll/, 'C:\\\\Program Files (x86)\\\\Google\\\\Chrome')[0];\n}\n\nfunction darwinMatch() {\n    return findSync(/PepperFlashPlayer.plugin/, '/Applications/Google Chrome.app/', true)[0];\n}\n\nexport default inferFlash;\n","/home/travis/build/npmtest/node-npmtest-nativefier/node_modules/nativefier/app/src/static/preload.js":"/**\n Preload file that will be executed in the renderer process\n */\nimport {ipcRenderer, webFrame} from 'electron';\nimport path from 'path';\nimport fs from 'fs';\n\nconst INJECT_JS_PATH = path.join(__dirname, '../../', 'inject/inject.js');\n\nsetNotificationCallback((title, opt) => {\n    ipcRenderer.send('notification', title, opt);\n});\n\ndocument.addEventListener('DOMContentLoaded', () => {\n    // do things\n\n    window.addEventListener('contextmenu', event => {\n        event.preventDefault();\n        let targetElement = event.srcElement;\n\n        // the clicked element is the deepest in the DOM, and may not be the <a> bearing the href\n        // for example, <a href=\"...\"><span>Google</span></a>\n        while (!targetElement.href && targetElement.parentElement) {\n            targetElement = targetElement.parentElement;\n        }\n        const targetHref = targetElement.href;\n\n        if (!targetHref) {\n            ipcRenderer.once('contextMenuClosed', () => {\n                clickSelector(event.target);\n                ipcRenderer.send('cancelNewWindowOverride');\n            });\n        }\n\n        ipcRenderer.send('contextMenuOpened', targetHref);\n    }, false);\n\n    injectScripts();\n});\n\nipcRenderer.on('params', (event, message) => {\n    const appArgs = JSON.parse(message);\n    console.log('nativefier.json', appArgs);\n});\n\nipcRenderer.on('debug', (event, message) => {\n    console.log('debug:', message);\n});\n\nipcRenderer.on('change-zoom', (event, message) => {\n    webFrame.setZoomFactor(message);\n});\n\n/**\n * Patches window.Notification to set a callback on a new Notification\n * @param callback\n */\nfunction setNotificationCallback(callback) {\n\n    const OldNotify = window.Notification;\n    const newNotify = (title, opt) => {\n        callback(title, opt);\n        return new OldNotify(title, opt);\n    };\n    newNotify.requestPermission = OldNotify.requestPermission.bind(OldNotify);\n    Object.defineProperty(newNotify, 'permission', {\n        get: () => {\n            return OldNotify.permission;\n        }\n    });\n\n    window.Notification = newNotify;\n}\n\nfunction clickSelector(element) {\n    const mouseEvent = new MouseEvent('click');\n    element.dispatchEvent(mouseEvent);\n}\n\nfunction injectScripts() {\n    const needToInject = fs.existsSync(INJECT_JS_PATH);\n    if (!needToInject) {\n        return;\n    }\n    require(INJECT_JS_PATH);\n}\n"}